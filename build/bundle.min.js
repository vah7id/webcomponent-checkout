(function () {
  'use strict';

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * True if the custom elements polyfill is in use.
   */
  const isCEPolyfill = typeof window !== 'undefined' &&
      window.customElements != null &&
      window.customElements.polyfillWrapFlushCallback !==
          undefined;
  /**
   * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
   * `container`.
   */
  const removeNodes = (container, start, end = null) => {
      while (start !== end) {
          const n = start.nextSibling;
          container.removeChild(start);
          start = n;
      }
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * An expression marker with embedded unique key to avoid collision with
   * possible text in templates.
   */
  const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
  /**
   * An expression marker used text-positions, multi-binding attributes, and
   * attributes with markup-like text values.
   */
  const nodeMarker = `<!--${marker}-->`;
  const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
  /**
   * Suffix appended to all bound attribute names.
   */
  const boundAttributeSuffix = '$lit$';
  /**
   * An updatable Template that tracks the location of dynamic parts.
   */
  class Template {
      constructor(result, element) {
          this.parts = [];
          this.element = element;
          const nodesToRemove = [];
          const stack = [];
          // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
          const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
          // Keeps track of the last index associated with a part. We try to delete
          // unnecessary nodes, but we never want to associate two different parts
          // to the same index. They must have a constant node between.
          let lastPartIndex = 0;
          let index = -1;
          let partIndex = 0;
          const { strings, values: { length } } = result;
          while (partIndex < length) {
              const node = walker.nextNode();
              if (node === null) {
                  // We've exhausted the content inside a nested template element.
                  // Because we still have parts (the outer for-loop), we know:
                  // - There is a template in the stack
                  // - The walker will find a nextNode outside the template
                  walker.currentNode = stack.pop();
                  continue;
              }
              index++;
              if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                  if (node.hasAttributes()) {
                      const attributes = node.attributes;
                      const { length } = attributes;
                      // Per
                      // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                      // attributes are not guaranteed to be returned in document order.
                      // In particular, Edge/IE can return them out of order, so we cannot
                      // assume a correspondence between part index and attribute index.
                      let count = 0;
                      for (let i = 0; i < length; i++) {
                          if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                              count++;
                          }
                      }
                      while (count-- > 0) {
                          // Get the template literal section leading up to the first
                          // expression in this attribute
                          const stringForPart = strings[partIndex];
                          // Find the attribute name
                          const name = lastAttributeNameRegex.exec(stringForPart)[2];
                          // Find the corresponding attribute
                          // All bound attributes have had a suffix added in
                          // TemplateResult#getHTML to opt out of special attribute
                          // handling. To look up the attribute value we also need to add
                          // the suffix.
                          const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                          const attributeValue = node.getAttribute(attributeLookupName);
                          node.removeAttribute(attributeLookupName);
                          const statics = attributeValue.split(markerRegex);
                          this.parts.push({ type: 'attribute', index, name, strings: statics });
                          partIndex += statics.length - 1;
                      }
                  }
                  if (node.tagName === 'TEMPLATE') {
                      stack.push(node);
                      walker.currentNode = node.content;
                  }
              }
              else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                  const data = node.data;
                  if (data.indexOf(marker) >= 0) {
                      const parent = node.parentNode;
                      const strings = data.split(markerRegex);
                      const lastIndex = strings.length - 1;
                      // Generate a new text node for each literal section
                      // These nodes are also used as the markers for node parts
                      for (let i = 0; i < lastIndex; i++) {
                          let insert;
                          let s = strings[i];
                          if (s === '') {
                              insert = createMarker();
                          }
                          else {
                              const match = lastAttributeNameRegex.exec(s);
                              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                  s = s.slice(0, match.index) + match[1] +
                                      match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                              }
                              insert = document.createTextNode(s);
                          }
                          parent.insertBefore(insert, node);
                          this.parts.push({ type: 'node', index: ++index });
                      }
                      // If there's no text, we must insert a comment to mark our place.
                      // Else, we can trust it will stick around after cloning.
                      if (strings[lastIndex] === '') {
                          parent.insertBefore(createMarker(), node);
                          nodesToRemove.push(node);
                      }
                      else {
                          node.data = strings[lastIndex];
                      }
                      // We have a part for each match found
                      partIndex += lastIndex;
                  }
              }
              else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                  if (node.data === marker) {
                      const parent = node.parentNode;
                      // Add a new marker node to be the startNode of the Part if any of
                      // the following are true:
                      //  * We don't have a previousSibling
                      //  * The previousSibling is already the start of a previous part
                      if (node.previousSibling === null || index === lastPartIndex) {
                          index++;
                          parent.insertBefore(createMarker(), node);
                      }
                      lastPartIndex = index;
                      this.parts.push({ type: 'node', index });
                      // If we don't have a nextSibling, keep this node so we have an end.
                      // Else, we can remove it to save future costs.
                      if (node.nextSibling === null) {
                          node.data = '';
                      }
                      else {
                          nodesToRemove.push(node);
                          index--;
                      }
                      partIndex++;
                  }
                  else {
                      let i = -1;
                      while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                          // Comment node has a binding marker inside, make an inactive part
                          // The binding won't work, but subsequent bindings will
                          // TODO (justinfagnani): consider whether it's even worth it to
                          // make bindings in comments work
                          this.parts.push({ type: 'node', index: -1 });
                          partIndex++;
                      }
                  }
              }
          }
          // Remove text binding nodes after the walk to not disturb the TreeWalker
          for (const n of nodesToRemove) {
              n.parentNode.removeChild(n);
          }
      }
  }
  const endsWith = (str, suffix) => {
      const index = str.length - suffix.length;
      return index >= 0 && str.slice(index) === suffix;
  };
  const isTemplatePartActive = (part) => part.index !== -1;
  // Allows `document.createComment('')` to be renamed for a
  // small manual size-savings.
  const createMarker = () => document.createComment('');
  /**
   * This regex extracts the attribute name preceding an attribute-position
   * expression. It does this by matching the syntax allowed for attributes
   * against the string literal directly preceding the expression, assuming that
   * the expression is in an attribute-value position.
   *
   * See attributes in the HTML spec:
   * https://www.w3.org/TR/html5/syntax.html#elements-attributes
   *
   * " \x09\x0a\x0c\x0d" are HTML space characters:
   * https://www.w3.org/TR/html5/infrastructure.html#space-characters
   *
   * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
   * space character except " ".
   *
   * So an attribute is:
   *  * The name: any character except a control character, space character, ('),
   *    ("), ">", "=", or "/"
   *  * Followed by zero or more space characters
   *  * Followed by "="
   *  * Followed by zero or more space characters
   *  * Followed by:
   *    * Any character except space, ('), ("), "<", ">", "=", (`), or
   *    * (") then any non-("), or
   *    * (') then any non-(')
   */
  const lastAttributeNameRegex = 
  // eslint-disable-next-line no-control-regex
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
  /**
   * Removes the list of nodes from a Template safely. In addition to removing
   * nodes from the Template, the Template part indices are updated to match
   * the mutated Template DOM.
   *
   * As the template is walked the removal state is tracked and
   * part indices are adjusted as needed.
   *
   * div
   *   div#1 (remove) <-- start removing (removing node is div#1)
   *     div
   *       div#2 (remove)  <-- continue removing (removing node is still div#1)
   *         div
   * div <-- stop removing since previous sibling is the removing node (div#1,
   * removed 4 nodes)
   */
  function removeNodesFromTemplate(template, nodesToRemove) {
      const { element: { content }, parts } = template;
      const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
      let partIndex = nextActiveIndexInTemplateParts(parts);
      let part = parts[partIndex];
      let nodeIndex = -1;
      let removeCount = 0;
      const nodesToRemoveInTemplate = [];
      let currentRemovingNode = null;
      while (walker.nextNode()) {
          nodeIndex++;
          const node = walker.currentNode;
          // End removal if stepped past the removing node
          if (node.previousSibling === currentRemovingNode) {
              currentRemovingNode = null;
          }
          // A node to remove was found in the template
          if (nodesToRemove.has(node)) {
              nodesToRemoveInTemplate.push(node);
              // Track node we're removing
              if (currentRemovingNode === null) {
                  currentRemovingNode = node;
              }
          }
          // When removing, increment count by which to adjust subsequent part indices
          if (currentRemovingNode !== null) {
              removeCount++;
          }
          while (part !== undefined && part.index === nodeIndex) {
              // If part is in a removed node deactivate it by setting index to -1 or
              // adjust the index as needed.
              part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
              // go to the next active part.
              partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
              part = parts[partIndex];
          }
      }
      nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
  }
  const countNodes = (node) => {
      let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
      const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
      while (walker.nextNode()) {
          count++;
      }
      return count;
  };
  const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
      for (let i = startIndex + 1; i < parts.length; i++) {
          const part = parts[i];
          if (isTemplatePartActive(part)) {
              return i;
          }
      }
      return -1;
  };
  /**
   * Inserts the given node into the Template, optionally before the given
   * refNode. In addition to inserting the node into the Template, the Template
   * part indices are updated to match the mutated Template DOM.
   */
  function insertNodeIntoTemplate(template, node, refNode = null) {
      const { element: { content }, parts } = template;
      // If there's no refNode, then put node at end of template.
      // No part indices need to be shifted in this case.
      if (refNode === null || refNode === undefined) {
          content.appendChild(node);
          return;
      }
      const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
      let partIndex = nextActiveIndexInTemplateParts(parts);
      let insertCount = 0;
      let walkerIndex = -1;
      while (walker.nextNode()) {
          walkerIndex++;
          const walkerNode = walker.currentNode;
          if (walkerNode === refNode) {
              insertCount = countNodes(node);
              refNode.parentNode.insertBefore(node, refNode);
          }
          while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
              // If we've inserted the node, simply adjust all subsequent parts
              if (insertCount > 0) {
                  while (partIndex !== -1) {
                      parts[partIndex].index += insertCount;
                      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                  }
                  return;
              }
              partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
          }
      }
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  const directives = new WeakMap();
  const isDirective = (o) => {
      return typeof o === 'function' && directives.has(o);
  };

  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * A sentinel value that signals that a value was handled by a directive and
   * should not be written to the DOM.
   */
  const noChange = {};
  /**
   * A sentinel value that signals a NodePart to fully clear its content.
   */
  const nothing = {};

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * An instance of a `Template` that can be attached to the DOM and updated
   * with new values.
   */
  class TemplateInstance {
      constructor(template, processor, options) {
          this.__parts = [];
          this.template = template;
          this.processor = processor;
          this.options = options;
      }
      update(values) {
          let i = 0;
          for (const part of this.__parts) {
              if (part !== undefined) {
                  part.setValue(values[i]);
              }
              i++;
          }
          for (const part of this.__parts) {
              if (part !== undefined) {
                  part.commit();
              }
          }
      }
      _clone() {
          // There are a number of steps in the lifecycle of a template instance's
          // DOM fragment:
          //  1. Clone - create the instance fragment
          //  2. Adopt - adopt into the main document
          //  3. Process - find part markers and create parts
          //  4. Upgrade - upgrade custom elements
          //  5. Update - set node, attribute, property, etc., values
          //  6. Connect - connect to the document. Optional and outside of this
          //     method.
          //
          // We have a few constraints on the ordering of these steps:
          //  * We need to upgrade before updating, so that property values will pass
          //    through any property setters.
          //  * We would like to process before upgrading so that we're sure that the
          //    cloned fragment is inert and not disturbed by self-modifying DOM.
          //  * We want custom elements to upgrade even in disconnected fragments.
          //
          // Given these constraints, with full custom elements support we would
          // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
          //
          // But Safari does not implement CustomElementRegistry#upgrade, so we
          // can not implement that order and still have upgrade-before-update and
          // upgrade disconnected fragments. So we instead sacrifice the
          // process-before-upgrade constraint, since in Custom Elements v1 elements
          // must not modify their light DOM in the constructor. We still have issues
          // when co-existing with CEv0 elements like Polymer 1, and with polyfills
          // that don't strictly adhere to the no-modification rule because shadow
          // DOM, which may be created in the constructor, is emulated by being placed
          // in the light DOM.
          //
          // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
          // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
          // in one step.
          //
          // The Custom Elements v1 polyfill supports upgrade(), so the order when
          // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
          // Connect.
          const fragment = isCEPolyfill ?
              this.template.element.content.cloneNode(true) :
              document.importNode(this.template.element.content, true);
          const stack = [];
          const parts = this.template.parts;
          // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
          const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
          let partIndex = 0;
          let nodeIndex = 0;
          let part;
          let node = walker.nextNode();
          // Loop through all the nodes and parts of a template
          while (partIndex < parts.length) {
              part = parts[partIndex];
              if (!isTemplatePartActive(part)) {
                  this.__parts.push(undefined);
                  partIndex++;
                  continue;
              }
              // Progress the tree walker until we find our next part's node.
              // Note that multiple parts may share the same node (attribute parts
              // on a single element), so this loop may not run at all.
              while (nodeIndex < part.index) {
                  nodeIndex++;
                  if (node.nodeName === 'TEMPLATE') {
                      stack.push(node);
                      walker.currentNode = node.content;
                  }
                  if ((node = walker.nextNode()) === null) {
                      // We've exhausted the content inside a nested template element.
                      // Because we still have parts (the outer for-loop), we know:
                      // - There is a template in the stack
                      // - The walker will find a nextNode outside the template
                      walker.currentNode = stack.pop();
                      node = walker.nextNode();
                  }
              }
              // We've arrived at our part's node.
              if (part.type === 'node') {
                  const part = this.processor.handleTextExpression(this.options);
                  part.insertAfterNode(node.previousSibling);
                  this.__parts.push(part);
              }
              else {
                  this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
              }
              partIndex++;
          }
          if (isCEPolyfill) {
              document.adoptNode(fragment);
              customElements.upgrade(fragment);
          }
          return fragment;
      }
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * Our TrustedTypePolicy for HTML which is declared using the html template
   * tag function.
   *
   * That HTML is a developer-authored constant, and is parsed with innerHTML
   * before any untrusted expressions have been mixed in. Therefor it is
   * considered safe by construction.
   */
  const policy = window.trustedTypes &&
      trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
  const commentMarker = ` ${marker} `;
  /**
   * The return type of `html`, which holds a Template and the values from
   * interpolated expressions.
   */
  class TemplateResult {
      constructor(strings, values, type, processor) {
          this.strings = strings;
          this.values = values;
          this.type = type;
          this.processor = processor;
      }
      /**
       * Returns a string of HTML used to create a `<template>` element.
       */
      getHTML() {
          const l = this.strings.length - 1;
          let html = '';
          let isCommentBinding = false;
          for (let i = 0; i < l; i++) {
              const s = this.strings[i];
              // For each binding we want to determine the kind of marker to insert
              // into the template source before it's parsed by the browser's HTML
              // parser. The marker type is based on whether the expression is in an
              // attribute, text, or comment position.
              //   * For node-position bindings we insert a comment with the marker
              //     sentinel as its text content, like <!--{{lit-guid}}-->.
              //   * For attribute bindings we insert just the marker sentinel for the
              //     first binding, so that we support unquoted attribute bindings.
              //     Subsequent bindings can use a comment marker because multi-binding
              //     attributes must be quoted.
              //   * For comment bindings we insert just the marker sentinel so we don't
              //     close the comment.
              //
              // The following code scans the template source, but is *not* an HTML
              // parser. We don't need to track the tree structure of the HTML, only
              // whether a binding is inside a comment, and if not, if it appears to be
              // the first binding in an attribute.
              const commentOpen = s.lastIndexOf('<!--');
              // We're in comment position if we have a comment open with no following
              // comment close. Because <-- can appear in an attribute value there can
              // be false positives.
              isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                  s.indexOf('-->', commentOpen + 1) === -1;
              // Check to see if we have an attribute-like sequence preceding the
              // expression. This can match "name=value" like structures in text,
              // comments, and attribute values, so there can be false-positives.
              const attributeMatch = lastAttributeNameRegex.exec(s);
              if (attributeMatch === null) {
                  // We're only in this branch if we don't have a attribute-like
                  // preceding sequence. For comments, this guards against unusual
                  // attribute values like <div foo="<!--${'bar'}">. Cases like
                  // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                  // below.
                  html += s + (isCommentBinding ? commentMarker : nodeMarker);
              }
              else {
                  // For attributes we use just a marker sentinel, and also append a
                  // $lit$ suffix to the name to opt-out of attribute-specific parsing
                  // that IE and Edge do for style and certain SVG attributes.
                  html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                      attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                      marker;
              }
          }
          html += this.strings[l];
          return html;
      }
      getTemplateElement() {
          const template = document.createElement('template');
          let value = this.getHTML();
          if (policy !== undefined) {
              // this is secure because `this.strings` is a TemplateStringsArray.
              // TODO: validate this when
              // https://github.com/tc39/proposal-array-is-template-object is
              // implemented.
              value = policy.createHTML(value);
          }
          template.innerHTML = value;
          return template;
      }
  }

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  const isPrimitive = (value) => {
      return (value === null ||
          !(typeof value === 'object' || typeof value === 'function'));
  };
  const isIterable = (value) => {
      return Array.isArray(value) ||
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          !!(value && value[Symbol.iterator]);
  };
  /**
   * Writes attribute values to the DOM for a group of AttributeParts bound to a
   * single attribute. The value is only set once even if there are multiple parts
   * for an attribute.
   */
  class AttributeCommitter {
      constructor(element, name, strings) {
          this.dirty = true;
          this.element = element;
          this.name = name;
          this.strings = strings;
          this.parts = [];
          for (let i = 0; i < strings.length - 1; i++) {
              this.parts[i] = this._createPart();
          }
      }
      /**
       * Creates a single part. Override this to create a differnt type of part.
       */
      _createPart() {
          return new AttributePart(this);
      }
      _getValue() {
          const strings = this.strings;
          const l = strings.length - 1;
          const parts = this.parts;
          // If we're assigning an attribute via syntax like:
          //    attr="${foo}"  or  attr=${foo}
          // but not
          //    attr="${foo} ${bar}" or attr="${foo} baz"
          // then we don't want to coerce the attribute value into one long
          // string. Instead we want to just return the value itself directly,
          // so that sanitizeDOMValue can get the actual value rather than
          // String(value)
          // The exception is if v is an array, in which case we do want to smash
          // it together into a string without calling String() on the array.
          //
          // This also allows trusted values (when using TrustedTypes) being
          // assigned to DOM sinks without being stringified in the process.
          if (l === 1 && strings[0] === '' && strings[1] === '') {
              const v = parts[0].value;
              if (typeof v === 'symbol') {
                  return String(v);
              }
              if (typeof v === 'string' || !isIterable(v)) {
                  return v;
              }
          }
          let text = '';
          for (let i = 0; i < l; i++) {
              text += strings[i];
              const part = parts[i];
              if (part !== undefined) {
                  const v = part.value;
                  if (isPrimitive(v) || !isIterable(v)) {
                      text += typeof v === 'string' ? v : String(v);
                  }
                  else {
                      for (const t of v) {
                          text += typeof t === 'string' ? t : String(t);
                      }
                  }
              }
          }
          text += strings[l];
          return text;
      }
      commit() {
          if (this.dirty) {
              this.dirty = false;
              this.element.setAttribute(this.name, this._getValue());
          }
      }
  }
  /**
   * A Part that controls all or part of an attribute value.
   */
  class AttributePart {
      constructor(committer) {
          this.value = undefined;
          this.committer = committer;
      }
      setValue(value) {
          if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
              this.value = value;
              // If the value is a not a directive, dirty the committer so that it'll
              // call setAttribute. If the value is a directive, it'll dirty the
              // committer if it calls setValue().
              if (!isDirective(value)) {
                  this.committer.dirty = true;
              }
          }
      }
      commit() {
          while (isDirective(this.value)) {
              const directive = this.value;
              this.value = noChange;
              directive(this);
          }
          if (this.value === noChange) {
              return;
          }
          this.committer.commit();
      }
  }
  /**
   * A Part that controls a location within a Node tree. Like a Range, NodePart
   * has start and end locations and can set and update the Nodes between those
   * locations.
   *
   * NodeParts support several value types: primitives, Nodes, TemplateResults,
   * as well as arrays and iterables of those types.
   */
  class NodePart {
      constructor(options) {
          this.value = undefined;
          this.__pendingValue = undefined;
          this.options = options;
      }
      /**
       * Appends this part into a container.
       *
       * This part must be empty, as its contents are not automatically moved.
       */
      appendInto(container) {
          this.startNode = container.appendChild(createMarker());
          this.endNode = container.appendChild(createMarker());
      }
      /**
       * Inserts this part after the `ref` node (between `ref` and `ref`'s next
       * sibling). Both `ref` and its next sibling must be static, unchanging nodes
       * such as those that appear in a literal section of a template.
       *
       * This part must be empty, as its contents are not automatically moved.
       */
      insertAfterNode(ref) {
          this.startNode = ref;
          this.endNode = ref.nextSibling;
      }
      /**
       * Appends this part into a parent part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */
      appendIntoPart(part) {
          part.__insert(this.startNode = createMarker());
          part.__insert(this.endNode = createMarker());
      }
      /**
       * Inserts this part after the `ref` part.
       *
       * This part must be empty, as its contents are not automatically moved.
       */
      insertAfterPart(ref) {
          ref.__insert(this.startNode = createMarker());
          this.endNode = ref.endNode;
          ref.endNode = this.startNode;
      }
      setValue(value) {
          this.__pendingValue = value;
      }
      commit() {
          if (this.startNode.parentNode === null) {
              return;
          }
          while (isDirective(this.__pendingValue)) {
              const directive = this.__pendingValue;
              this.__pendingValue = noChange;
              directive(this);
          }
          const value = this.__pendingValue;
          if (value === noChange) {
              return;
          }
          if (isPrimitive(value)) {
              if (value !== this.value) {
                  this.__commitText(value);
              }
          }
          else if (value instanceof TemplateResult) {
              this.__commitTemplateResult(value);
          }
          else if (value instanceof Node) {
              this.__commitNode(value);
          }
          else if (isIterable(value)) {
              this.__commitIterable(value);
          }
          else if (value === nothing) {
              this.value = nothing;
              this.clear();
          }
          else {
              // Fallback, will render the string representation
              this.__commitText(value);
          }
      }
      __insert(node) {
          this.endNode.parentNode.insertBefore(node, this.endNode);
      }
      __commitNode(value) {
          if (this.value === value) {
              return;
          }
          this.clear();
          this.__insert(value);
          this.value = value;
      }
      __commitText(value) {
          const node = this.startNode.nextSibling;
          value = value == null ? '' : value;
          // If `value` isn't already a string, we explicitly convert it here in case
          // it can't be implicitly converted - i.e. it's a symbol.
          const valueAsString = typeof value === 'string' ? value : String(value);
          if (node === this.endNode.previousSibling &&
              node.nodeType === 3 /* Node.TEXT_NODE */) {
              // If we only have a single text node between the markers, we can just
              // set its value, rather than replacing it.
              // TODO(justinfagnani): Can we just check if this.value is primitive?
              node.data = valueAsString;
          }
          else {
              this.__commitNode(document.createTextNode(valueAsString));
          }
          this.value = value;
      }
      __commitTemplateResult(value) {
          const template = this.options.templateFactory(value);
          if (this.value instanceof TemplateInstance &&
              this.value.template === template) {
              this.value.update(value.values);
          }
          else {
              // Make sure we propagate the template processor from the TemplateResult
              // so that we use its syntax extension, etc. The template factory comes
              // from the render function options so that it can control template
              // caching and preprocessing.
              const instance = new TemplateInstance(template, value.processor, this.options);
              const fragment = instance._clone();
              instance.update(value.values);
              this.__commitNode(fragment);
              this.value = instance;
          }
      }
      __commitIterable(value) {
          // For an Iterable, we create a new InstancePart per item, then set its
          // value to the item. This is a little bit of overhead for every item in
          // an Iterable, but it lets us recurse easily and efficiently update Arrays
          // of TemplateResults that will be commonly returned from expressions like:
          // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
          // If _value is an array, then the previous render was of an
          // iterable and _value will contain the NodeParts from the previous
          // render. If _value is not an array, clear this part and make a new
          // array for NodeParts.
          if (!Array.isArray(this.value)) {
              this.value = [];
              this.clear();
          }
          // Lets us keep track of how many items we stamped so we can clear leftover
          // items from a previous render
          const itemParts = this.value;
          let partIndex = 0;
          let itemPart;
          for (const item of value) {
              // Try to reuse an existing part
              itemPart = itemParts[partIndex];
              // If no existing part, create a new one
              if (itemPart === undefined) {
                  itemPart = new NodePart(this.options);
                  itemParts.push(itemPart);
                  if (partIndex === 0) {
                      itemPart.appendIntoPart(this);
                  }
                  else {
                      itemPart.insertAfterPart(itemParts[partIndex - 1]);
                  }
              }
              itemPart.setValue(item);
              itemPart.commit();
              partIndex++;
          }
          if (partIndex < itemParts.length) {
              // Truncate the parts array so _value reflects the current state
              itemParts.length = partIndex;
              this.clear(itemPart && itemPart.endNode);
          }
      }
      clear(startNode = this.startNode) {
          removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
      }
  }
  /**
   * Implements a boolean attribute, roughly as defined in the HTML
   * specification.
   *
   * If the value is truthy, then the attribute is present with a value of
   * ''. If the value is falsey, the attribute is removed.
   */
  class BooleanAttributePart {
      constructor(element, name, strings) {
          this.value = undefined;
          this.__pendingValue = undefined;
          if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
              throw new Error('Boolean attributes can only contain a single expression');
          }
          this.element = element;
          this.name = name;
          this.strings = strings;
      }
      setValue(value) {
          this.__pendingValue = value;
      }
      commit() {
          while (isDirective(this.__pendingValue)) {
              const directive = this.__pendingValue;
              this.__pendingValue = noChange;
              directive(this);
          }
          if (this.__pendingValue === noChange) {
              return;
          }
          const value = !!this.__pendingValue;
          if (this.value !== value) {
              if (value) {
                  this.element.setAttribute(this.name, '');
              }
              else {
                  this.element.removeAttribute(this.name);
              }
              this.value = value;
          }
          this.__pendingValue = noChange;
      }
  }
  /**
   * Sets attribute values for PropertyParts, so that the value is only set once
   * even if there are multiple parts for a property.
   *
   * If an expression controls the whole property value, then the value is simply
   * assigned to the property under control. If there are string literals or
   * multiple expressions, then the strings are expressions are interpolated into
   * a string first.
   */
  class PropertyCommitter extends AttributeCommitter {
      constructor(element, name, strings) {
          super(element, name, strings);
          this.single =
              (strings.length === 2 && strings[0] === '' && strings[1] === '');
      }
      _createPart() {
          return new PropertyPart(this);
      }
      _getValue() {
          if (this.single) {
              return this.parts[0].value;
          }
          return super._getValue();
      }
      commit() {
          if (this.dirty) {
              this.dirty = false;
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this.element[this.name] = this._getValue();
          }
      }
  }
  class PropertyPart extends AttributePart {
  }
  // Detect event listener options support. If the `capture` property is read
  // from the options object, then options are supported. If not, then the third
  // argument to add/removeEventListener is interpreted as the boolean capture
  // value so we should only pass the `capture` property.
  let eventOptionsSupported = false;
  // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
  // blocks right into the body of a module
  (() => {
      try {
          const options = {
              get capture() {
                  eventOptionsSupported = true;
                  return false;
              }
          };
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          window.addEventListener('test', options, options);
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          window.removeEventListener('test', options, options);
      }
      catch (_e) {
          // event options not supported
      }
  })();
  class EventPart {
      constructor(element, eventName, eventContext) {
          this.value = undefined;
          this.__pendingValue = undefined;
          this.element = element;
          this.eventName = eventName;
          this.eventContext = eventContext;
          this.__boundHandleEvent = (e) => this.handleEvent(e);
      }
      setValue(value) {
          this.__pendingValue = value;
      }
      commit() {
          while (isDirective(this.__pendingValue)) {
              const directive = this.__pendingValue;
              this.__pendingValue = noChange;
              directive(this);
          }
          if (this.__pendingValue === noChange) {
              return;
          }
          const newListener = this.__pendingValue;
          const oldListener = this.value;
          const shouldRemoveListener = newListener == null ||
              oldListener != null &&
                  (newListener.capture !== oldListener.capture ||
                      newListener.once !== oldListener.once ||
                      newListener.passive !== oldListener.passive);
          const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
          if (shouldRemoveListener) {
              this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
          }
          if (shouldAddListener) {
              this.__options = getOptions(newListener);
              this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
          }
          this.value = newListener;
          this.__pendingValue = noChange;
      }
      handleEvent(event) {
          if (typeof this.value === 'function') {
              this.value.call(this.eventContext || this.element, event);
          }
          else {
              this.value.handleEvent(event);
          }
      }
  }
  // We copy options because of the inconsistent behavior of browsers when reading
  // the third argument of add/removeEventListener. IE11 doesn't support options
  // at all. Chrome 41 only reads `capture` if the argument is an object.
  const getOptions = (o) => o &&
      (eventOptionsSupported ?
          { capture: o.capture, passive: o.passive, once: o.once } :
          o.capture);

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * The default TemplateFactory which caches Templates keyed on
   * result.type and result.strings.
   */
  function templateFactory(result) {
      let templateCache = templateCaches$1.get(result.type);
      if (templateCache === undefined) {
          templateCache = {
              stringsArray: new WeakMap(),
              keyString: new Map()
          };
          templateCaches$1.set(result.type, templateCache);
      }
      let template = templateCache.stringsArray.get(result.strings);
      if (template !== undefined) {
          return template;
      }
      // If the TemplateStringsArray is new, generate a key from the strings
      // This key is shared between all templates with identical content
      const key = result.strings.join(marker);
      // Check if we already have a Template for this key
      template = templateCache.keyString.get(key);
      if (template === undefined) {
          // If we have not seen this key before, create a new Template
          template = new Template(result, result.getTemplateElement());
          // Cache the Template for this key
          templateCache.keyString.set(key, template);
      }
      // Cache all future queries for this TemplateStringsArray
      templateCache.stringsArray.set(result.strings, template);
      return template;
  }
  const templateCaches$1 = new Map();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  const parts = new WeakMap();
  /**
   * Renders a template result or other value to a container.
   *
   * To update a container with new values, reevaluate the template literal and
   * call `render` with the new result.
   *
   * @param result Any value renderable by NodePart - typically a TemplateResult
   *     created by evaluating a template tag like `html` or `svg`.
   * @param container A DOM parent to render to. The entire contents are either
   *     replaced, or efficiently updated if the same result type was previous
   *     rendered there.
   * @param options RenderOptions for the entire render tree rendered to this
   *     container. Render options must *not* change between renders to the same
   *     container, as those changes will not effect previously rendered DOM.
   */
  const render$1 = (result, container, options) => {
      let part = parts.get(container);
      if (part === undefined) {
          removeNodes(container, container.firstChild);
          parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
          part.appendInto(container);
      }
      part.setValue(result);
      part.commit();
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  /**
   * Creates Parts when a template is instantiated.
   */
  class DefaultTemplateProcessor {
      /**
       * Create parts for an attribute-position binding, given the event, attribute
       * name, and string literals.
       *
       * @param element The element containing the binding
       * @param name  The attribute name
       * @param strings The string literals. There are always at least two strings,
       *   event for fully-controlled bindings with a single expression.
       */
      handleAttributeExpressions(element, name, strings, options) {
          const prefix = name[0];
          if (prefix === '.') {
              const committer = new PropertyCommitter(element, name.slice(1), strings);
              return committer.parts;
          }
          if (prefix === '@') {
              return [new EventPart(element, name.slice(1), options.eventContext)];
          }
          if (prefix === '?') {
              return [new BooleanAttributePart(element, name.slice(1), strings)];
          }
          const committer = new AttributeCommitter(element, name, strings);
          return committer.parts;
      }
      /**
       * Create parts for a text-position binding.
       * @param templateFactory
       */
      handleTextExpression(options) {
          return new NodePart(options);
      }
  }
  const defaultTemplateProcessor = new DefaultTemplateProcessor();

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // IMPORTANT: do not change the property name or the assignment expression.
  // This line will be used in regexes to search for lit-html usage.
  // TODO(justinfagnani): inject version number at build time
  if (typeof window !== 'undefined') {
      (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.0');
  }
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   */
  const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // Get a key to lookup in `templateCaches`.
  const getTemplateCacheKey$1 = (type, scopeName) => `${type}--${scopeName}`;
  let compatibleShadyCSSVersion$1 = true;
  if (typeof window.ShadyCSS === 'undefined') {
      compatibleShadyCSSVersion$1 = false;
  }
  else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
      console.warn(`Incompatible ShadyCSS version detected. ` +
          `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
          `@webcomponents/shadycss@1.3.1.`);
      compatibleShadyCSSVersion$1 = false;
  }
  /**
   * Template factory which scopes template DOM using ShadyCSS.
   * @param scopeName {string}
   */
  const shadyTemplateFactory$1 = (scopeName) => (result) => {
      const cacheKey = getTemplateCacheKey$1(result.type, scopeName);
      let templateCache = templateCaches$1.get(cacheKey);
      if (templateCache === undefined) {
          templateCache = {
              stringsArray: new WeakMap(),
              keyString: new Map()
          };
          templateCaches$1.set(cacheKey, templateCache);
      }
      let template = templateCache.stringsArray.get(result.strings);
      if (template !== undefined) {
          return template;
      }
      const key = result.strings.join(marker);
      template = templateCache.keyString.get(key);
      if (template === undefined) {
          const element = result.getTemplateElement();
          if (compatibleShadyCSSVersion$1) {
              window.ShadyCSS.prepareTemplateDom(element, scopeName);
          }
          template = new Template(result, element);
          templateCache.keyString.set(key, template);
      }
      templateCache.stringsArray.set(result.strings, template);
      return template;
  };
  const TEMPLATE_TYPES = ['html', 'svg'];
  /**
   * Removes all style elements from Templates for the given scopeName.
   */
  const removeStylesFromLitTemplates = (scopeName) => {
      TEMPLATE_TYPES.forEach((type) => {
          const templates = templateCaches$1.get(getTemplateCacheKey$1(type, scopeName));
          if (templates !== undefined) {
              templates.keyString.forEach((template) => {
                  const { element: { content } } = template;
                  // IE 11 doesn't support the iterable param Set constructor
                  const styles = new Set();
                  Array.from(content.querySelectorAll('style')).forEach((s) => {
                      styles.add(s);
                  });
                  removeNodesFromTemplate(template, styles);
              });
          }
      });
  };
  const shadyRenderSet = new Set();
  /**
   * For the given scope name, ensures that ShadyCSS style scoping is performed.
   * This is done just once per scope name so the fragment and template cannot
   * be modified.
   * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
   * to be scoped and appended to the document
   * (2) removes style elements from all lit-html Templates for this scope name.
   *
   * Note, <style> elements can only be placed into templates for the
   * initial rendering of the scope. If <style> elements are included in templates
   * dynamically rendered to the scope (after the first scope render), they will
   * not be scoped and the <style> will be left in the template and rendered
   * output.
   */
  const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
      shadyRenderSet.add(scopeName);
      // If `renderedDOM` is stamped from a Template, then we need to edit that
      // Template's underlying template element. Otherwise, we create one here
      // to give to ShadyCSS, which still requires one while scoping.
      const templateElement = !!template ? template.element : document.createElement('template');
      // Move styles out of rendered DOM and store.
      const styles = renderedDOM.querySelectorAll('style');
      const { length } = styles;
      // If there are no styles, skip unnecessary work
      if (length === 0) {
          // Ensure prepareTemplateStyles is called to support adding
          // styles via `prepareAdoptedCssText` since that requires that
          // `prepareTemplateStyles` is called.
          //
          // ShadyCSS will only update styles containing @apply in the template
          // given to `prepareTemplateStyles`. If no lit Template was given,
          // ShadyCSS will not be able to update uses of @apply in any relevant
          // template. However, this is not a problem because we only create the
          // template for the purpose of supporting `prepareAdoptedCssText`,
          // which doesn't support @apply at all.
          window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
          return;
      }
      const condensedStyle = document.createElement('style');
      // Collect styles into a single style. This helps us make sure ShadyCSS
      // manipulations will not prevent us from being able to fix up template
      // part indices.
      // NOTE: collecting styles is inefficient for browsers but ShadyCSS
      // currently does this anyway. When it does not, this should be changed.
      for (let i = 0; i < length; i++) {
          const style = styles[i];
          style.parentNode.removeChild(style);
          condensedStyle.textContent += style.textContent;
      }
      // Remove styles from nested templates in this scope.
      removeStylesFromLitTemplates(scopeName);
      // And then put the condensed style into the "root" template passed in as
      // `template`.
      const content = templateElement.content;
      if (!!template) {
          insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
      }
      else {
          content.insertBefore(condensedStyle, content.firstChild);
      }
      // Note, it's important that ShadyCSS gets the template that `lit-html`
      // will actually render so that it can update the style inside when
      // needed (e.g. @apply native Shadow DOM case).
      window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
      const style = content.querySelector('style');
      if (window.ShadyCSS.nativeShadow && style !== null) {
          // When in native Shadow DOM, ensure the style created by ShadyCSS is
          // included in initially rendered output (`renderedDOM`).
          renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
      }
      else if (!!template) {
          // When no style is left in the template, parts will be broken as a
          // result. To fix this, we put back the style node ShadyCSS removed
          // and then tell lit to remove that node from the template.
          // There can be no style in the template in 2 cases (1) when Shady DOM
          // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
          // is in use ShadyCSS removes the style if it contains no content.
          // NOTE, ShadyCSS creates its own style so we can safely add/remove
          // `condensedStyle` here.
          content.insertBefore(condensedStyle, content.firstChild);
          const removes = new Set();
          removes.add(condensedStyle);
          removeNodesFromTemplate(template, removes);
      }
  };
  /**
   * Extension to the standard `render` method which supports rendering
   * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
   * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
   * or when the webcomponentsjs
   * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
   *
   * Adds a `scopeName` option which is used to scope element DOM and stylesheets
   * when native ShadowDOM is unavailable. The `scopeName` will be added to
   * the class attribute of all rendered DOM. In addition, any style elements will
   * be automatically re-written with this `scopeName` selector and moved out
   * of the rendered DOM and into the document `<head>`.
   *
   * It is common to use this render method in conjunction with a custom element
   * which renders a shadowRoot. When this is done, typically the element's
   * `localName` should be used as the `scopeName`.
   *
   * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
   * custom properties (needed only on older browsers like IE11) and a shim for
   * a deprecated feature called `@apply` that supports applying a set of css
   * custom properties to a given location.
   *
   * Usage considerations:
   *
   * * Part values in `<style>` elements are only applied the first time a given
   * `scopeName` renders. Subsequent changes to parts in style elements will have
   * no effect. Because of this, parts in style elements should only be used for
   * values that will never change, for example parts that set scope-wide theme
   * values or parts which render shared style elements.
   *
   * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
   * custom element's `constructor` is not supported. Instead rendering should
   * either done asynchronously, for example at microtask timing (for example
   * `Promise.resolve()`), or be deferred until the first time the element's
   * `connectedCallback` runs.
   *
   * Usage considerations when using shimmed custom properties or `@apply`:
   *
   * * Whenever any dynamic changes are made which affect
   * css custom properties, `ShadyCSS.styleElement(element)` must be called
   * to update the element. There are two cases when this is needed:
   * (1) the element is connected to a new parent, (2) a class is added to the
   * element that causes it to match different custom properties.
   * To address the first case when rendering a custom element, `styleElement`
   * should be called in the element's `connectedCallback`.
   *
   * * Shimmed custom properties may only be defined either for an entire
   * shadowRoot (for example, in a `:host` rule) or via a rule that directly
   * matches an element with a shadowRoot. In other words, instead of flowing from
   * parent to child as do native css custom properties, shimmed custom properties
   * flow only from shadowRoots to nested shadowRoots.
   *
   * * When using `@apply` mixing css shorthand property names with
   * non-shorthand names (for example `border` and `border-width`) is not
   * supported.
   */
  const render = (result, container, options) => {
      if (!options || typeof options !== 'object' || !options.scopeName) {
          throw new Error('The `scopeName` option is required.');
      }
      const scopeName = options.scopeName;
      const hasRendered = parts.has(container);
      const needsScoping = compatibleShadyCSSVersion$1 &&
          container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
          !!container.host;
      // Handle first render to a scope specially...
      const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
      // On first scope render, render into a fragment; this cannot be a single
      // fragment that is reused since nested renders can occur synchronously.
      const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
      render$1(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory$1(scopeName) }, options));
      // When performing first scope render,
      // (1) We've rendered into a fragment so that there's a chance to
      // `prepareTemplateStyles` before sub-elements hit the DOM
      // (which might cause them to render based on a common pattern of
      // rendering in a custom element's `connectedCallback`);
      // (2) Scope the template with ShadyCSS one time only for this scope.
      // (3) Render the fragment into the container and make sure the
      // container knows its `part` is the one we just rendered. This ensures
      // DOM will be re-used on subsequent renders.
      if (firstScopeRender) {
          const part = parts.get(renderContainer);
          parts.delete(renderContainer);
          // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
          // that should apply to `renderContainer` even if the rendered value is
          // not a TemplateInstance. However, it will only insert scoped styles
          // into the document if `prepareTemplateStyles` has already been called
          // for the given scope name.
          const template = part.value instanceof TemplateInstance ?
              part.value.template :
              undefined;
          prepareTemplateStyles(scopeName, renderContainer, template);
          removeNodes(container, container.firstChild);
          container.appendChild(renderContainer);
          parts.set(container, part);
      }
      // After elements have hit the DOM, update styling if this is the
      // initial render to this container.
      // This is needed whenever dynamic changes are made so it would be
      // safest to do every render; however, this would regress performance
      // so we leave it up to the user to call `ShadyCSS.styleElement`
      // for dynamic changes.
      if (!hasRendered && needsScoping) {
          window.ShadyCSS.styleElement(container.host);
      }
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var _a;
  /**
   * Use this module if you want to create your own base class extending
   * [[UpdatingElement]].
   * @packageDocumentation
   */
  /*
   * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
   * replaced at compile time by the munged name for object[property]. We cannot
   * alias this function, so we have to use a small shim that has the same
   * behavior when not compiling.
   */
  window.JSCompiler_renameProperty =
      (prop, _obj) => prop;
  const defaultConverter = {
      toAttribute(value, type) {
          switch (type) {
              case Boolean:
                  return value ? '' : null;
              case Object:
              case Array:
                  // if the value is `null` or `undefined` pass this through
                  // to allow removing/no change behavior.
                  return value == null ? value : JSON.stringify(value);
          }
          return value;
      },
      fromAttribute(value, type) {
          switch (type) {
              case Boolean:
                  return value !== null;
              case Number:
                  return value === null ? null : Number(value);
              case Object:
              case Array:
                  return JSON.parse(value);
          }
          return value;
      }
  };
  /**
   * Change function that returns true if `value` is different from `oldValue`.
   * This method is used as the default for a property's `hasChanged` function.
   */
  const notEqual = (value, old) => {
      // This ensures (old==NaN, value==NaN) always returns false
      return old !== value && (old === old || value === value);
  };
  const defaultPropertyDeclaration = {
      attribute: true,
      type: String,
      converter: defaultConverter,
      reflect: false,
      hasChanged: notEqual
  };
  const STATE_HAS_UPDATED = 1;
  const STATE_UPDATE_REQUESTED = 1 << 2;
  const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
  const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
  /**
   * The Closure JS Compiler doesn't currently have good support for static
   * property semantics where "this" is dynamic (e.g.
   * https://github.com/google/closure-compiler/issues/3177 and others) so we use
   * this hack to bypass any rewriting by the compiler.
   */
  const finalized = 'finalized';
  /**
   * Base element class which manages element properties and attributes. When
   * properties change, the `update` method is asynchronously called. This method
   * should be supplied by subclassers to render updates as desired.
   * @noInheritDoc
   */
  class UpdatingElement extends HTMLElement {
      constructor() {
          super();
          this.initialize();
      }
      /**
       * Returns a list of attributes corresponding to the registered properties.
       * @nocollapse
       */
      static get observedAttributes() {
          // note: piggy backing on this to ensure we're finalized.
          this.finalize();
          const attributes = [];
          // Use forEach so this works even if for/of loops are compiled to for loops
          // expecting arrays
          this._classProperties.forEach((v, p) => {
              const attr = this._attributeNameForProperty(p, v);
              if (attr !== undefined) {
                  this._attributeToPropertyMap.set(attr, p);
                  attributes.push(attr);
              }
          });
          return attributes;
      }
      /**
       * Ensures the private `_classProperties` property metadata is created.
       * In addition to `finalize` this is also called in `createProperty` to
       * ensure the `@property` decorator can add property metadata.
       */
      /** @nocollapse */
      static _ensureClassProperties() {
          // ensure private storage for property declarations.
          if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
              this._classProperties = new Map();
              // NOTE: Workaround IE11 not supporting Map constructor argument.
              const superProperties = Object.getPrototypeOf(this)._classProperties;
              if (superProperties !== undefined) {
                  superProperties.forEach((v, k) => this._classProperties.set(k, v));
              }
          }
      }
      /**
       * Creates a property accessor on the element prototype if one does not exist
       * and stores a PropertyDeclaration for the property with the given options.
       * The property setter calls the property's `hasChanged` property option
       * or uses a strict identity check to determine whether or not to request
       * an update.
       *
       * This method may be overridden to customize properties; however,
       * when doing so, it's important to call `super.createProperty` to ensure
       * the property is setup correctly. This method calls
       * `getPropertyDescriptor` internally to get a descriptor to install.
       * To customize what properties do when they are get or set, override
       * `getPropertyDescriptor`. To customize the options for a property,
       * implement `createProperty` like this:
       *
       * static createProperty(name, options) {
       *   options = Object.assign(options, {myOption: true});
       *   super.createProperty(name, options);
       * }
       *
       * @nocollapse
       */
      static createProperty(name, options = defaultPropertyDeclaration) {
          // Note, since this can be called by the `@property` decorator which
          // is called before `finalize`, we ensure storage exists for property
          // metadata.
          this._ensureClassProperties();
          this._classProperties.set(name, options);
          // Do not generate an accessor if the prototype already has one, since
          // it would be lost otherwise and that would never be the user's intention;
          // Instead, we expect users to call `requestUpdate` themselves from
          // user-defined accessors. Note that if the super has an accessor we will
          // still overwrite it
          if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
              return;
          }
          const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
          const descriptor = this.getPropertyDescriptor(name, key, options);
          if (descriptor !== undefined) {
              Object.defineProperty(this.prototype, name, descriptor);
          }
      }
      /**
       * Returns a property descriptor to be defined on the given named property.
       * If no descriptor is returned, the property will not become an accessor.
       * For example,
       *
       *   class MyElement extends LitElement {
       *     static getPropertyDescriptor(name, key, options) {
       *       const defaultDescriptor =
       *           super.getPropertyDescriptor(name, key, options);
       *       const setter = defaultDescriptor.set;
       *       return {
       *         get: defaultDescriptor.get,
       *         set(value) {
       *           setter.call(this, value);
       *           // custom action.
       *         },
       *         configurable: true,
       *         enumerable: true
       *       }
       *     }
       *   }
       *
       * @nocollapse
       */
      static getPropertyDescriptor(name, key, options) {
          return {
              // tslint:disable-next-line:no-any no symbol in index
              get() {
                  return this[key];
              },
              set(value) {
                  const oldValue = this[name];
                  this[key] = value;
                  this
                      .requestUpdateInternal(name, oldValue, options);
              },
              configurable: true,
              enumerable: true
          };
      }
      /**
       * Returns the property options associated with the given property.
       * These options are defined with a PropertyDeclaration via the `properties`
       * object or the `@property` decorator and are registered in
       * `createProperty(...)`.
       *
       * Note, this method should be considered "final" and not overridden. To
       * customize the options for a given property, override `createProperty`.
       *
       * @nocollapse
       * @final
       */
      static getPropertyOptions(name) {
          return this._classProperties && this._classProperties.get(name) ||
              defaultPropertyDeclaration;
      }
      /**
       * Creates property accessors for registered properties and ensures
       * any superclasses are also finalized.
       * @nocollapse
       */
      static finalize() {
          // finalize any superclasses
          const superCtor = Object.getPrototypeOf(this);
          if (!superCtor.hasOwnProperty(finalized)) {
              superCtor.finalize();
          }
          this[finalized] = true;
          this._ensureClassProperties();
          // initialize Map populated in observedAttributes
          this._attributeToPropertyMap = new Map();
          // make any properties
          // Note, only process "own" properties since this element will inherit
          // any properties defined on the superClass, and finalization ensures
          // the entire prototype chain is finalized.
          if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
              const props = this.properties;
              // support symbols in properties (IE11 does not support this)
              const propKeys = [
                  ...Object.getOwnPropertyNames(props),
                  ...(typeof Object.getOwnPropertySymbols === 'function') ?
                      Object.getOwnPropertySymbols(props) :
                      []
              ];
              // This for/of is ok because propKeys is an array
              for (const p of propKeys) {
                  // note, use of `any` is due to TypeSript lack of support for symbol in
                  // index types
                  // tslint:disable-next-line:no-any no symbol in index
                  this.createProperty(p, props[p]);
              }
          }
      }
      /**
       * Returns the property name for the given attribute `name`.
       * @nocollapse
       */
      static _attributeNameForProperty(name, options) {
          const attribute = options.attribute;
          return attribute === false ?
              undefined :
              (typeof attribute === 'string' ?
                  attribute :
                  (typeof name === 'string' ? name.toLowerCase() : undefined));
      }
      /**
       * Returns true if a property should request an update.
       * Called when a property value is set and uses the `hasChanged`
       * option for the property if present or a strict identity check.
       * @nocollapse
       */
      static _valueHasChanged(value, old, hasChanged = notEqual) {
          return hasChanged(value, old);
      }
      /**
       * Returns the property value for the given attribute value.
       * Called via the `attributeChangedCallback` and uses the property's
       * `converter` or `converter.fromAttribute` property option.
       * @nocollapse
       */
      static _propertyValueFromAttribute(value, options) {
          const type = options.type;
          const converter = options.converter || defaultConverter;
          const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
          return fromAttribute ? fromAttribute(value, type) : value;
      }
      /**
       * Returns the attribute value for the given property value. If this
       * returns undefined, the property will *not* be reflected to an attribute.
       * If this returns null, the attribute will be removed, otherwise the
       * attribute will be set to the value.
       * This uses the property's `reflect` and `type.toAttribute` property options.
       * @nocollapse
       */
      static _propertyValueToAttribute(value, options) {
          if (options.reflect === undefined) {
              return;
          }
          const type = options.type;
          const converter = options.converter;
          const toAttribute = converter && converter.toAttribute ||
              defaultConverter.toAttribute;
          return toAttribute(value, type);
      }
      /**
       * Performs element initialization. By default captures any pre-set values for
       * registered properties.
       */
      initialize() {
          this._updateState = 0;
          this._updatePromise =
              new Promise((res) => this._enableUpdatingResolver = res);
          this._changedProperties = new Map();
          this._saveInstanceProperties();
          // ensures first update will be caught by an early access of
          // `updateComplete`
          this.requestUpdateInternal();
      }
      /**
       * Fixes any properties set on the instance before upgrade time.
       * Otherwise these would shadow the accessor and break these properties.
       * The properties are stored in a Map which is played back after the
       * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
       * (<=41), properties created for native platform properties like (`id` or
       * `name`) may not have default values set in the element constructor. On
       * these browsers native properties appear on instances and therefore their
       * default value will overwrite any element default (e.g. if the element sets
       * this.id = 'id' in the constructor, the 'id' will become '' since this is
       * the native platform default).
       */
      _saveInstanceProperties() {
          // Use forEach so this works even if for/of loops are compiled to for loops
          // expecting arrays
          this.constructor
              ._classProperties.forEach((_v, p) => {
              if (this.hasOwnProperty(p)) {
                  const value = this[p];
                  delete this[p];
                  if (!this._instanceProperties) {
                      this._instanceProperties = new Map();
                  }
                  this._instanceProperties.set(p, value);
              }
          });
      }
      /**
       * Applies previously saved instance properties.
       */
      _applyInstanceProperties() {
          // Use forEach so this works even if for/of loops are compiled to for loops
          // expecting arrays
          // tslint:disable-next-line:no-any
          this._instanceProperties.forEach((v, p) => this[p] = v);
          this._instanceProperties = undefined;
      }
      connectedCallback() {
          // Ensure first connection completes an update. Updates cannot complete
          // before connection.
          this.enableUpdating();
      }
      enableUpdating() {
          if (this._enableUpdatingResolver !== undefined) {
              this._enableUpdatingResolver();
              this._enableUpdatingResolver = undefined;
          }
      }
      /**
       * Allows for `super.disconnectedCallback()` in extensions while
       * reserving the possibility of making non-breaking feature additions
       * when disconnecting at some point in the future.
       */
      disconnectedCallback() {
      }
      /**
       * Synchronizes property values when attributes change.
       */
      attributeChangedCallback(name, old, value) {
          if (old !== value) {
              this._attributeToProperty(name, value);
          }
      }
      _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
          const ctor = this.constructor;
          const attr = ctor._attributeNameForProperty(name, options);
          if (attr !== undefined) {
              const attrValue = ctor._propertyValueToAttribute(value, options);
              // an undefined value does not change the attribute.
              if (attrValue === undefined) {
                  return;
              }
              // Track if the property is being reflected to avoid
              // setting the property again via `attributeChangedCallback`. Note:
              // 1. this takes advantage of the fact that the callback is synchronous.
              // 2. will behave incorrectly if multiple attributes are in the reaction
              // stack at time of calling. However, since we process attributes
              // in `update` this should not be possible (or an extreme corner case
              // that we'd like to discover).
              // mark state reflecting
              this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
              if (attrValue == null) {
                  this.removeAttribute(attr);
              }
              else {
                  this.setAttribute(attr, attrValue);
              }
              // mark state not reflecting
              this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
          }
      }
      _attributeToProperty(name, value) {
          // Use tracking info to avoid deserializing attribute value if it was
          // just set from a property setter.
          if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
              return;
          }
          const ctor = this.constructor;
          // Note, hint this as an `AttributeMap` so closure clearly understands
          // the type; it has issues with tracking types through statics
          // tslint:disable-next-line:no-unnecessary-type-assertion
          const propName = ctor._attributeToPropertyMap.get(name);
          if (propName !== undefined) {
              const options = ctor.getPropertyOptions(propName);
              // mark state reflecting
              this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
              this[propName] =
                  // tslint:disable-next-line:no-any
                  ctor._propertyValueFromAttribute(value, options);
              // mark state not reflecting
              this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
          }
      }
      /**
       * This protected version of `requestUpdate` does not access or return the
       * `updateComplete` promise. This promise can be overridden and is therefore
       * not free to access.
       */
      requestUpdateInternal(name, oldValue, options) {
          let shouldRequestUpdate = true;
          // If we have a property key, perform property update steps.
          if (name !== undefined) {
              const ctor = this.constructor;
              options = options || ctor.getPropertyOptions(name);
              if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                  if (!this._changedProperties.has(name)) {
                      this._changedProperties.set(name, oldValue);
                  }
                  // Add to reflecting properties set.
                  // Note, it's important that every change has a chance to add the
                  // property to `_reflectingProperties`. This ensures setting
                  // attribute + property reflects correctly.
                  if (options.reflect === true &&
                      !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                      if (this._reflectingProperties === undefined) {
                          this._reflectingProperties = new Map();
                      }
                      this._reflectingProperties.set(name, options);
                  }
              }
              else {
                  // Abort the request if the property should not be considered changed.
                  shouldRequestUpdate = false;
              }
          }
          if (!this._hasRequestedUpdate && shouldRequestUpdate) {
              this._updatePromise = this._enqueueUpdate();
          }
      }
      /**
       * Requests an update which is processed asynchronously. This should
       * be called when an element should update based on some state not triggered
       * by setting a property. In this case, pass no arguments. It should also be
       * called when manually implementing a property setter. In this case, pass the
       * property `name` and `oldValue` to ensure that any configured property
       * options are honored. Returns the `updateComplete` Promise which is resolved
       * when the update completes.
       *
       * @param name {PropertyKey} (optional) name of requesting property
       * @param oldValue {any} (optional) old value of requesting property
       * @returns {Promise} A Promise that is resolved when the update completes.
       */
      requestUpdate(name, oldValue) {
          this.requestUpdateInternal(name, oldValue);
          return this.updateComplete;
      }
      /**
       * Sets up the element to asynchronously update.
       */
      async _enqueueUpdate() {
          this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
          try {
              // Ensure any previous update has resolved before updating.
              // This `await` also ensures that property changes are batched.
              await this._updatePromise;
          }
          catch (e) {
              // Ignore any previous errors. We only care that the previous cycle is
              // done. Any error should have been handled in the previous update.
          }
          const result = this.performUpdate();
          // If `performUpdate` returns a Promise, we await it. This is done to
          // enable coordinating updates with a scheduler. Note, the result is
          // checked to avoid delaying an additional microtask unless we need to.
          if (result != null) {
              await result;
          }
          return !this._hasRequestedUpdate;
      }
      get _hasRequestedUpdate() {
          return (this._updateState & STATE_UPDATE_REQUESTED);
      }
      get hasUpdated() {
          return (this._updateState & STATE_HAS_UPDATED);
      }
      /**
       * Performs an element update. Note, if an exception is thrown during the
       * update, `firstUpdated` and `updated` will not be called.
       *
       * You can override this method to change the timing of updates. If this
       * method is overridden, `super.performUpdate()` must be called.
       *
       * For instance, to schedule updates to occur just before the next frame:
       *
       * ```
       * protected async performUpdate(): Promise<unknown> {
       *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
       *   super.performUpdate();
       * }
       * ```
       */
      performUpdate() {
          // Abort any update if one is not pending when this is called.
          // This can happen if `performUpdate` is called early to "flush"
          // the update.
          if (!this._hasRequestedUpdate) {
              return;
          }
          // Mixin instance properties once, if they exist.
          if (this._instanceProperties) {
              this._applyInstanceProperties();
          }
          let shouldUpdate = false;
          const changedProperties = this._changedProperties;
          try {
              shouldUpdate = this.shouldUpdate(changedProperties);
              if (shouldUpdate) {
                  this.update(changedProperties);
              }
              else {
                  this._markUpdated();
              }
          }
          catch (e) {
              // Prevent `firstUpdated` and `updated` from running when there's an
              // update exception.
              shouldUpdate = false;
              // Ensure element can accept additional updates after an exception.
              this._markUpdated();
              throw e;
          }
          if (shouldUpdate) {
              if (!(this._updateState & STATE_HAS_UPDATED)) {
                  this._updateState = this._updateState | STATE_HAS_UPDATED;
                  this.firstUpdated(changedProperties);
              }
              this.updated(changedProperties);
          }
      }
      _markUpdated() {
          this._changedProperties = new Map();
          this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
      }
      /**
       * Returns a Promise that resolves when the element has completed updating.
       * The Promise value is a boolean that is `true` if the element completed the
       * update without triggering another update. The Promise result is `false` if
       * a property was set inside `updated()`. If the Promise is rejected, an
       * exception was thrown during the update.
       *
       * To await additional asynchronous work, override the `_getUpdateComplete`
       * method. For example, it is sometimes useful to await a rendered element
       * before fulfilling this Promise. To do this, first await
       * `super._getUpdateComplete()`, then any subsequent state.
       *
       * @returns {Promise} The Promise returns a boolean that indicates if the
       * update resolved without triggering another update.
       */
      get updateComplete() {
          return this._getUpdateComplete();
      }
      /**
       * Override point for the `updateComplete` promise.
       *
       * It is not safe to override the `updateComplete` getter directly due to a
       * limitation in TypeScript which means it is not possible to call a
       * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
       * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
       * This method should be overridden instead. For example:
       *
       *   class MyElement extends LitElement {
       *     async _getUpdateComplete() {
       *       await super._getUpdateComplete();
       *       await this._myChild.updateComplete;
       *     }
       *   }
       */
      _getUpdateComplete() {
          return this._updatePromise;
      }
      /**
       * Controls whether or not `update` should be called when the element requests
       * an update. By default, this method always returns `true`, but this can be
       * customized to control when to update.
       *
       * @param _changedProperties Map of changed properties with old values
       */
      shouldUpdate(_changedProperties) {
          return true;
      }
      /**
       * Updates the element. This method reflects property values to attributes.
       * It can be overridden to render and keep updated element DOM.
       * Setting properties inside this method will *not* trigger
       * another update.
       *
       * @param _changedProperties Map of changed properties with old values
       */
      update(_changedProperties) {
          if (this._reflectingProperties !== undefined &&
              this._reflectingProperties.size > 0) {
              // Use forEach so this works even if for/of loops are compiled to for
              // loops expecting arrays
              this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
              this._reflectingProperties = undefined;
          }
          this._markUpdated();
      }
      /**
       * Invoked whenever the element is updated. Implement to perform
       * post-updating tasks via DOM APIs, for example, focusing an element.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * @param _changedProperties Map of changed properties with old values
       */
      updated(_changedProperties) {
      }
      /**
       * Invoked when the element is first updated. Implement to perform one time
       * work on the element after update.
       *
       * Setting properties inside this method will trigger the element to update
       * again after this update cycle completes.
       *
       * @param _changedProperties Map of changed properties with old values
       */
      firstUpdated(_changedProperties) {
      }
  }
  _a = finalized;
  /**
   * Marks class as having finished creating properties.
   */
  UpdatingElement[_a] = true;

  /**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */
  /**
   * Whether the current browser supports `adoptedStyleSheets`.
   */
  const supportsAdoptingStyleSheets = (window.ShadowRoot) &&
      (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&
      ('adoptedStyleSheets' in Document.prototype) &&
      ('replace' in CSSStyleSheet.prototype);
  const constructionToken = Symbol();
  class CSSResult {
      constructor(cssText, safeToken) {
          if (safeToken !== constructionToken) {
              throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
          }
          this.cssText = cssText;
      }
      // Note, this is a getter so that it's lazy. In practice, this means
      // stylesheets are not created until the first element instance is made.
      get styleSheet() {
          if (this._styleSheet === undefined) {
              // Note, if `supportsAdoptingStyleSheets` is true then we assume
              // CSSStyleSheet is constructable.
              if (supportsAdoptingStyleSheets) {
                  this._styleSheet = new CSSStyleSheet();
                  this._styleSheet.replaceSync(this.cssText);
              }
              else {
                  this._styleSheet = null;
              }
          }
          return this._styleSheet;
      }
      toString() {
          return this.cssText;
      }
  }
  /**
   * Wrap a value for interpolation in a [[`css`]] tagged template literal.
   *
   * This is unsafe because untrusted CSS text can be used to phone home
   * or exfiltrate data to an attacker controlled site. Take care to only use
   * this with trusted input.
   */
  const unsafeCSS = (value) => {
      return new CSSResult(String(value), constructionToken);
  };
  const textFromCSSResult = (value) => {
      if (value instanceof CSSResult) {
          return value.cssText;
      }
      else if (typeof value === 'number') {
          return value;
      }
      else {
          throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
      }
  };
  /**
   * Template tag which which can be used with LitElement's [[LitElement.styles |
   * `styles`]] property to set element styles. For security reasons, only literal
   * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]
   * may be used inside a template string part.
   */
  const css = (strings, ...values) => {
      const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
      return new CSSResult(cssText, constructionToken);
  };

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // IMPORTANT: do not change the property name or the assignment expression.
  // This line will be used in regexes to search for LitElement usage.
  // TODO(justinfagnani): inject version number at build time
  (window['litElementVersions'] || (window['litElementVersions'] = []))
      .push('2.4.0');
  /**
   * Sentinal value used to avoid calling lit-html's render function when
   * subclasses do not implement `render`
   */
  const renderNotImplemented = {};
  /**
   * Base element class that manages element properties and attributes, and
   * renders a lit-html template.
   *
   * To define a component, subclass `LitElement` and implement a
   * `render` method to provide the component's template. Define properties
   * using the [[`properties`]] property or the [[`property`]] decorator.
   */
  class LitElement extends UpdatingElement {
      /**
       * Return the array of styles to apply to the element.
       * Override this method to integrate into a style management system.
       *
       * @nocollapse
       */
      static getStyles() {
          return this.styles;
      }
      /** @nocollapse */
      static _getUniqueStyles() {
          // Only gather styles once per class
          if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
              return;
          }
          // Take care not to call `this.getStyles()` multiple times since this
          // generates new CSSResults each time.
          // TODO(sorvell): Since we do not cache CSSResults by input, any
          // shared styles will generate new stylesheet objects, which is wasteful.
          // This should be addressed when a browser ships constructable
          // stylesheets.
          const userStyles = this.getStyles();
          if (Array.isArray(userStyles)) {
              // De-duplicate styles preserving the _last_ instance in the set.
              // This is a performance optimization to avoid duplicated styles that can
              // occur especially when composing via subclassing.
              // The last item is kept to try to preserve the cascade order with the
              // assumption that it's most important that last added styles override
              // previous styles.
              const addStyles = (styles, set) => styles.reduceRight((set, s) => 
              // Note: On IE set.add() does not return the set
              Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);
              // Array.from does not work on Set in IE, otherwise return
              // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()
              const set = addStyles(userStyles, new Set());
              const styles = [];
              set.forEach((v) => styles.unshift(v));
              this._styles = styles;
          }
          else {
              this._styles = userStyles === undefined ? [] : [userStyles];
          }
          // Ensure that there are no invalid CSSStyleSheet instances here. They are
          // invalid in two conditions.
          // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but
          //     this is impossible to check except via .replaceSync or use
          // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is
          //     false)
          this._styles = this._styles.map((s) => {
              if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
                  // Flatten the cssText from the passed constructible stylesheet (or
                  // undetectable non-constructible stylesheet). The user might have
                  // expected to update their stylesheets over time, but the alternative
                  // is a crash.
                  const cssText = Array.prototype.slice.call(s.cssRules)
                      .reduce((css, rule) => css + rule.cssText, '');
                  return unsafeCSS(cssText);
              }
              return s;
          });
      }
      /**
       * Performs element initialization. By default this calls
       * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
       * captures any pre-set values for registered properties.
       */
      initialize() {
          super.initialize();
          this.constructor._getUniqueStyles();
          this.renderRoot = this.createRenderRoot();
          // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
          // element's getRootNode(). While this could be done, we're choosing not to
          // support this now since it would require different logic around de-duping.
          if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
              this.adoptStyles();
          }
      }
      /**
       * Returns the node into which the element should render and by default
       * creates and returns an open shadowRoot. Implement to customize where the
       * element's DOM is rendered. For example, to render into the element's
       * childNodes, return `this`.
       * @returns {Element|DocumentFragment} Returns a node into which to render.
       */
      createRenderRoot() {
          return this.attachShadow({ mode: 'open' });
      }
      /**
       * Applies styling to the element shadowRoot using the [[`styles`]]
       * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
       * available and will fallback otherwise. When Shadow DOM is polyfilled,
       * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
       * is available but `adoptedStyleSheets` is not, styles are appended to the
       * end of the `shadowRoot` to [mimic spec
       * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
       */
      adoptStyles() {
          const styles = this.constructor._styles;
          if (styles.length === 0) {
              return;
          }
          // There are three separate cases here based on Shadow DOM support.
          // (1) shadowRoot polyfilled: use ShadyCSS
          // (2) shadowRoot.adoptedStyleSheets available: use it
          // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
          // rendering
          if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
              window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
          }
          else if (supportsAdoptingStyleSheets) {
              this.renderRoot.adoptedStyleSheets =
                  styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
          }
          else {
              // This must be done after rendering so the actual style insertion is done
              // in `update`.
              this._needsShimAdoptedStyleSheets = true;
          }
      }
      connectedCallback() {
          super.connectedCallback();
          // Note, first update/render handles styleElement so we only call this if
          // connected after first update.
          if (this.hasUpdated && window.ShadyCSS !== undefined) {
              window.ShadyCSS.styleElement(this);
          }
      }
      /**
       * Updates the element. This method reflects property values to attributes
       * and calls `render` to render DOM via lit-html. Setting properties inside
       * this method will *not* trigger another update.
       * @param _changedProperties Map of changed properties with old values
       */
      update(changedProperties) {
          // Setting properties in `render` should not trigger an update. Since
          // updates are allowed after super.update, it's important to call `render`
          // before that.
          const templateResult = this.render();
          super.update(changedProperties);
          // If render is not implemented by the component, don't call lit-html render
          if (templateResult !== renderNotImplemented) {
              this.constructor
                  .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
          }
          // When native Shadow DOM is used but adoptedStyles are not supported,
          // insert styling after rendering to ensure adoptedStyles have highest
          // priority.
          if (this._needsShimAdoptedStyleSheets) {
              this._needsShimAdoptedStyleSheets = false;
              this.constructor._styles.forEach((s) => {
                  const style = document.createElement('style');
                  style.textContent = s.cssText;
                  this.renderRoot.appendChild(style);
              });
          }
      }
      /**
       * Invoked on each update to perform rendering tasks. This method may return
       * any value renderable by lit-html's `NodePart` - typically a
       * `TemplateResult`. Setting properties inside this method will *not* trigger
       * the element to update.
       */
      render() {
          return renderNotImplemented;
      }
  }
  /**
   * Ensure this class is marked as `finalized` as an optimization ensuring
   * it will not needlessly try to `finalize`.
   *
   * Note this property name is a string to prevent breaking Closure JS Compiler
   * optimizations. See updating-element.ts for more information.
   */
  LitElement['finalized'] = true;
  /**
   * Reference to the underlying library method used to render the element's
   * DOM. By default, points to the `render` method from lit-html's shady-render
   * module.
   *
   * **Most users will never need to touch this property.**
   *
   * This  property should not be confused with the `render` instance method,
   * which should be overridden to define a template for the element.
   *
   * Advanced users creating a new base class based on LitElement can override
   * this property to point to a custom render method with a signature that
   * matches [shady-render's `render`
   * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).
   *
   * @nocollapse
   */
  LitElement.render = render;

  const appliedClassMixins = new WeakMap();

  /** Vefify if the Mixin was previously applyed
   * @private
   * @param {function} mixin      Mixin being applyed
   * @param {object} superClass   Class receiving the new mixin
   * @returns {boolean}
   */
  function wasMixinPreviouslyApplied(mixin, superClass) {
    let klass = superClass;
    while (klass) {
      if (appliedClassMixins.get(klass) === mixin) {
        return true;
      }
      klass = Object.getPrototypeOf(klass);
    }
    return false;
  }

  /** Apply each mixin in the chain to make sure they are not applied more than once to the final class.
   * @export
   * @param {function} mixin      Mixin to be applyed
   * @returns {object}            Mixed class with mixin applied
   */
  function dedupeMixin(mixin) {
    return superClass => {
      if (wasMixinPreviouslyApplied(mixin, superClass)) {
        return superClass;
      }
      const mixedClass = mixin(superClass);
      appliedClassMixins.set(mixedClass, mixin);
      return mixedClass;
    };
  }

  /**
   * Cache class that allows to search in a cache hierarchy.
   * @template T, Q
   */
  class Cache {
    /**
     * Creates a Cache instance
     * @param {Cache} [parent]
     */
    constructor(parent) {
      this._parent = parent;
      this._cache = new Map();
    }

    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     *
     * @param {T} key - The key of the element to test for presence in the Cache object.
     * @return {boolean}
     */
    has(key) {
      return !!(this._cache.has(key) || (this._parent && this._parent._cache.has(key)));
    }

    /**
     * Adds or updates an element with a specified key and a value to a Cache object.
     *
     * @param {T} key - The key of the element to add to the Cache object.
     * @param {Q} value - The value of the element to add to the Cache object.
     * @return {Cache<T, Q>} the cache object
     */
    set(key, value) {
      this._cache.set(key, value);

      return this;
    }

    /**
     * Returns a specified element from a Map object. If the value that is associated to the provided key is an
     * object, then you will get a reference to that object and any change made to that object will effectively modify
     * it inside the Map object.
     *
     * @param {T} key - The key of the element to return from the Cache object.
     * @return {Q}
     */
    get(key) {
      return this._cache.get(key) || (this._parent && this._parent._cache.get(key));
    }
  }

  /**
   * Global counter to scope the custom elements
   *
   * @type {number}
   */
  let counter = Math.round(Math.random() * 100000);

  /**
   * Allowed tag name chars
   *
   * @type {string}
   */
  const chars$1 = `-|\\.|[0-9]|[a-z]`;

  /**
   * Regular expression to check if a value is a valid tag name
   *
   * @type {RegExp}
   */
  const tagRegExp = new RegExp(`[a-z](${chars$1})*-(${chars$1})*`);

  /**
   * Checks if the tag name is valid
   *
   * @param {string} tag
   * @returns {boolean}
   */
  const isValid = tag => tagRegExp.exec(tag) !== null;

  /**
   * Checks if the tag is already registered
   *
   * @param {string} name
   * @param {CustomElementRegistry} registry
   * @returns {boolean}
   */
  const isTagRegistered = (name, registry) => !!registry.get(name);

  /**
   * Given a tag name scopes it with a number suffix
   *
   * @param {string} tagName
   * @param {CustomElementRegistry} registry
   * @returns {string} scoped tag name
   */
  const incrementTagName = (tagName, registry) => {
    const newTagName = `${tagName}-${(counter += 1)}`;

    if (isTagRegistered(newTagName, registry)) {
      return incrementTagName(tagName, registry);
    }

    return newTagName;
  };

  /**
   * Creates a unique scoped tag name
   *
   * @exports
   * @param {string} tagName - tag name to scope
   * @param {CustomElementRegistry} registry
   * @returns {string} scoped tag name
   */
  function createUniqueTag(tagName, registry = customElements) {
    if (!isValid(tagName)) {
      throw new Error('tagName is invalid');
    }

    return incrementTagName(tagName, registry);
  }

  /**
   * The global cache for tag names
   *
   * @type {WeakMap<typeof HTMLElement, string>}
   */
  const globalTagsCache = new WeakMap();

  /**
   * Adds a tag to the global tags cache
   *
   * @param {string} tag
   * @param {typeof HTMLElement} klass
   */
  const addToGlobalTagsCache = (tag, klass) => globalTagsCache.set(klass, tag);

  /**
   * Gets a tag from the global tags cache
   *
   * @exports
   * @param {typeof HTMLElement} klass
   * @returns {undefined|string}
   */
  const getFromGlobalTagsCache = klass => globalTagsCache.get(klass);

  /**
   * Checks if klass is a subclass of HTMLElement
   *
   * @param {typeof HTMLElement} klass
   * @returns {boolean}
   */
  const extendsHTMLElement = klass => Object.prototype.isPrototypeOf.call(HTMLElement, klass);

  /**
   * Defines a custom element
   *
   * @param {string} tagName
   * @param {typeof HTMLElement} klass
   * @param {CustomElementRegistry} registry
   */
  const defineElement = (tagName, klass, registry = customElements) => {
    addToGlobalTagsCache(tagName, klass);
    registry.define(tagName, class extends klass {});
  };

  /**
   * Stores a lazy element in the cache to be used in future
   *
   * @param {string} tagName
   * @param {CustomElementRegistry} registry
   * @param {import('./Cache.js').Cache<string, string>} tagsCache
   * @returns {string}
   */
  const storeLazyElementInCache = (tagName, registry, tagsCache) => {
    const tag = createUniqueTag(tagName, registry);

    if (!tagsCache) {
      throw new Error('Lazy scoped elements requires the use of tags cache');
    }

    tagsCache.set(tagName, tag);

    return tag;
  };

  /**
   * Define a scoped custom element storing the scoped tag name in the cache
   *
   * @param {string} tagName
   * @param {typeof HTMLElement} klass
   * @param {import('./Cache.js').Cache<string, string>} tagsCache
   * @returns {string}
   */
  const defineElementAndStoreInCache = (tagName, klass, tagsCache) => {
    const registry = customElements;

    if (!extendsHTMLElement(klass)) {
      return storeLazyElementInCache(tagName, registry, tagsCache);
    }

    if (klass === customElements.get(tagName)) {
      addToGlobalTagsCache(tagName, klass);

      return tagName;
    }

    const tag = createUniqueTag(tagName, registry);
    // @ts-ignore
    // we extend it just in case the class has been defined manually
    defineElement(tag, klass, registry);

    return tag;
  };

  /**
   * Gets a scoped tag name from the cache or generates a new one and defines the element if needed
   *
   * @exports
   * @param {string} tagName
   * @param {typeof HTMLElement} klass
   * @param {import('./Cache.js').Cache<string, string>} tagsCache
   * @returns {string}
   */
  function registerElement(tagName, klass, tagsCache = undefined) {
    const tag =
      getFromGlobalTagsCache(klass) ||
      (tagsCache && tagsCache.get(tagName)) ||
      defineElementAndStoreInCache(tagName, klass, tagsCache);

    return tag;
  }

  /**
   * Defines a lazy element
   *
   * @param {string} tagName
   * @param {typeof HTMLElement} klass
   * @param {import('./Cache.js').Cache<string, string>} tagsCache
   */
  function defineScopedElement(tagName, klass, tagsCache) {
    const tag = tagsCache.get(tagName);

    if (tag) {
      if (customElements.get(tag) === undefined) {
        defineElement(tag, klass, customElements);
      }
    } else {
      tagsCache.set(tagName, registerElement(tagName, klass, tagsCache));
    }
  }

  /**
   * @typedef {import('./types').ScopedElementsMap} ScopedElementsMap
   */

  /**
   * Allowed tag name chars
   *
   * @type {string}
   */
  const chars = `-|\\.|[0-9]|[a-z]`;

  /**
   * Regular Expression to find a custom element tag
   *
   * @type {RegExp}
   */
  const re = new RegExp(`<\\/?([a-z](${chars})*-(${chars})*)`, 'g');

  /**
   * The global cache of processed string arrays
   *
   * @type {Cache<TemplateStringsArray, TemplateStringsArray>}
   */
  const globalCache = new Cache();

  /**
   * Find custom element tags in the string
   *
   * @param {string} str
   * @returns {RegExpExecArray[]}
   */
  const matchAll = str => {
    const matches = [];
    let result;
    // eslint-disable-next-line no-cond-assign
    while ((result = re.exec(str)) !== null) {
      matches.push(result);
    }

    return matches;
  };

  /**
   * Transforms a string array into another one with resolved scoped elements and caches it for future references
   *
   * @param {TemplateStringsArray} strings
   * @param {ScopedElementsMap} scopedElements
   * @param {Cache<TemplateStringsArray, TemplateStringsArray>} templateCache
   * @param {Cache<string, string>} tagsCache
   * @returns {TemplateStringsArray}
   */
  const transformTemplate$1 = (strings, scopedElements, templateCache, tagsCache) => {
    const transformedStrings = strings.map(str => {
      let acc = str;
      const matches = matchAll(str);

      for (let i = matches.length - 1; i >= 0; i -= 1) {
        const item = matches[i];
        const [block, tagName] = item;
        const tag = registerElement(tagName, scopedElements[tagName], tagsCache);
        const start = item.index + block.length - tagName.length;
        const end = start + tagName.length;
        const isClosingTag = block.indexOf('</') === 0;

        acc =
          acc.slice(0, start) +
          (isClosingTag ? tag : `${tag} data-tag-name="${tagName}"`) +
          acc.slice(end);
      }

      return acc;
    });

    // @ts-ignore
    // noinspection JSCheckFunctionSignatures
    templateCache.set(strings, transformedStrings);

    // @ts-ignore
    // noinspection JSValidateTypes
    return transformedStrings;
  };

  /**
   * Obtains the cached strings array with resolved scoped elements or creates it
   *
   * @exports
   * @param {TemplateStringsArray} strings
   * @param {ScopedElementsMap} scopedElements
   * @param {import('./Cache.js').Cache<TemplateStringsArray, TemplateStringsArray>} templateCache
   * @param {import('./Cache.js').Cache<string, string>} tagsCache
   * @returns {TemplateStringsArray}
   */
  function transform(strings, scopedElements, templateCache = globalCache, tagsCache) {
    return (
      templateCache.get(strings) ||
      transformTemplate$1(strings, scopedElements, templateCache, tagsCache)
    );
  }

  const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;

  let compatibleShadyCSSVersion = true;

  // @ts-ignore
  const { ShadyCSS } = window;

  if (typeof ShadyCSS === 'undefined') {
    compatibleShadyCSSVersion = false;
  } else if (typeof ShadyCSS.prepareTemplateDom === 'undefined') {
    compatibleShadyCSSVersion = false;
  }

  /**
   * Template factory which scopes template DOM using ShadyCSS.
   * @param scopeName {string}
   */
  const shadyTemplateFactory = scopeName => result => {
    const cacheKey = getTemplateCacheKey(result.type, scopeName);
    let templateCache = templateCaches$1.get(cacheKey);
    if (templateCache === undefined) {
      templateCache = {
        stringsArray: new WeakMap(),
        keyString: new Map(),
      };
      templateCaches$1.set(cacheKey, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== undefined) {
      return template;
    }
    const key = result.strings.join(marker);
    template = templateCache.keyString.get(key);
    if (template === undefined) {
      const element = result.getTemplateElement();
      if (compatibleShadyCSSVersion) {
        ShadyCSS.prepareTemplateDom(element, scopeName);
      }
      template = new Template(result, element);
      templateCache.keyString.set(key, template);
    }
    templateCache.stringsArray.set(result.strings, template);
    return template;
  };

  /* eslint-disable no-use-before-define */

  /**
   * @typedef {import('./types').ScopedElementsMixin} ScopedElementsMixin
   * @typedef {import('./types').ScopedElementsMap} ScopedElementsMap
   * @typedef {import("lit-element").LitElement} LitElement
   * @typedef {import('lit-html/lib/shady-render').ShadyRenderOptions} ShadyRenderOptions
   * @typedef {function(TemplateResult, Element|DocumentFragment|ShadowRoot, ShadyRenderOptions): void} RenderFunction
   */

  /**
   * Template caches
   *
   * @type {WeakMap<Function, Cache<TemplateStringsArray, TemplateStringsArray>>}
   */
  const templateCaches = new WeakMap();

  /**
   * Retrieves or creates a templateCache for a specific key
   *
   * @param {Function} key
   * @returns {Cache<TemplateStringsArray, TemplateStringsArray>}
   */
  const getTemplateCache = key => {
    if (!templateCaches.has(key)) {
      // @ts-ignore
      templateCaches.set(key, new Cache(templateCaches.get(key.constructor)));
    }

    return templateCaches.get(key);
  };

  /**
   * Tags caches
   *
   * @type {WeakMap<object, Cache<string, string>>}
   */
  const tagsCaches = new WeakMap();

  /**
   * Retrieves or creates a tagsCache for a specific key
   * @param {object} key
   * @returns {Cache<string, string>}
   */
  const getTagsCache = key => {
    if (!tagsCaches.has(key)) {
      tagsCaches.set(key, new Cache(tagsCaches.get(key.constructor)));
    }

    return tagsCaches.get(key);
  };

  /**
   * Transforms an array of TemplateResults or arrays into another one with resolved scoped elements
   *
   * @param {ReadonlyArray} items
   * @param {ScopedElementsMap} scopedElements
   * @param {Cache<TemplateStringsArray, TemplateStringsArray>} templateCache
   * @param {Cache<string, string>} tagsCache
   * @returns {ReadonlyArray}
   */
  const transformArray = (items, scopedElements, templateCache, tagsCache) =>
    items.map(value => {
      if (value instanceof TemplateResult) {
        return transformTemplate(value, scopedElements, templateCache, tagsCache);
      }

      if (Array.isArray(value)) {
        return transformArray(value, scopedElements, templateCache, tagsCache);
      }

      return value;
    });

  /**
   * Transforms a TemplateResult into another one with resolved scoped elements
   *
   * @param {TemplateResult} template
   * @param {ScopedElementsMap} scopedElements
   * @param {Cache<TemplateStringsArray, TemplateStringsArray>} templateCache
   * @param {Cache<string, string>} tagsCache
   * @returns {TemplateResult}
   */
  const transformTemplate = (template, scopedElements, templateCache, tagsCache) =>
    new TemplateResult(
      transform(template.strings, scopedElements, templateCache, tagsCache),
      transformArray(template.values, scopedElements, templateCache, tagsCache),
      template.type,
      template.processor,
    );

  /**
   * Gets an instance of the ScopedElementsTemplateFactory
   *
   * @param {string} scopeName
   * @param {ScopedElementsMap} scopedElements
   * @param {Cache<TemplateStringsArray, TemplateStringsArray>} templateCache
   * @param {Cache<string, string>} tagsCache
   * @returns {function(any): any}
   */
  const scopedElementsTemplateFactory = (
    scopeName,
    scopedElements,
    templateCache,
    tagsCache,
  ) => template => {
    const newTemplate = transformTemplate(template, scopedElements, templateCache, tagsCache);

    return shadyTemplateFactory(scopeName)(newTemplate);
  };

  /** @type {ScopedElementsMixin} */
  const ScopedElementsMixinImplementation = superclass =>
    class ScopedElementsHost extends superclass {
      /**
       * Obtains the scoped elements definitions map
       *
       * @returns {ScopedElementsMap}
       */
      static get scopedElements() {
        return {};
      }

      /** @override */
      static render(template, container, options) {
        if (!options || typeof options !== 'object' || !options.scopeName) {
          throw new Error('The `scopeName` option is required.');
        }
        const { scopeName, eventContext } = options;

        const templateCache = getTemplateCache(eventContext);
        const tagsCache = getTagsCache(eventContext);
        const { scopedElements } = this;

        return super.render(template, container, {
          ...options,
          templateFactory: scopedElementsTemplateFactory(
            scopeName,
            scopedElements,
            templateCache,
            tagsCache,
          ),
        });
      }

      /**
       * Defines a scoped element
       *
       * @param {string} tagName
       * @param {typeof HTMLElement} klass
       */
      defineScopedElement(tagName, klass) {
        return defineScopedElement(tagName, klass, getTagsCache(this));
      }

      /**
       * Returns a scoped tag name
       *
       * @deprecated Please, use the instance method instead of the static one. This static method is not able to
       * obtain the tagName of lazy defined elements, while the instance one is.
       * @param {string} tagName
       * @returns {string|undefined}
       */
      static getScopedTagName(tagName) {
        // @ts-ignore
        const klass = this.scopedElements[tagName];

        return klass
          ? registerElement(tagName, klass, getTagsCache(this))
          : getTagsCache(this).get(tagName);
      }

      /**
       * Returns a scoped tag name
       *
       * @param {string} tagName
       * @returns {string|undefined}
       */
      getScopedTagName(tagName) {
        // @ts-ignore
        const klass = this.constructor.scopedElements[tagName];

        return klass
          ? registerElement(tagName, klass, getTagsCache(this))
          : getTagsCache(this).get(tagName);
      }
    };

  const ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);

  /**
   * @typedef {import('../types/DisabledMixinTypes').DisabledMixin} DisabledMixin
   */

  /**
   * @type {DisabledMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('../index').LitElement>} superclass
   */
  const DisabledMixinImplementation = superclass =>
    // eslint-disable-next-line no-shadow
    class extends superclass {
      static get properties() {
        return {
          disabled: {
            type: Boolean,
            reflect: true,
          },
        };
      }

      constructor() {
        super();
        /** @protected */
        this._requestedToBeDisabled = false;
        /** @private */
        this.__isUserSettingDisabled = true;
        /** @private */
        this.__restoreDisabledTo = false;
        this.disabled = false;
      }

      makeRequestToBeDisabled() {
        if (this._requestedToBeDisabled === false) {
          this._requestedToBeDisabled = true;
          this.__restoreDisabledTo = this.disabled;
          this.__internalSetDisabled(true);
        }
      }

      retractRequestToBeDisabled() {
        if (this._requestedToBeDisabled === true) {
          this._requestedToBeDisabled = false;
          this.__internalSetDisabled(this.__restoreDisabledTo);
        }
      }

      /**
       * @param {boolean} value
       * @private
       */
      __internalSetDisabled(value) {
        this.__isUserSettingDisabled = false;
        this.disabled = value;
        this.__isUserSettingDisabled = true;
      }

      /**
       * @param {PropertyKey} name
       * @param {?} oldValue
       */
      requestUpdateInternal(name, oldValue) {
        super.requestUpdateInternal(name, oldValue);
        if (name === 'disabled') {
          if (this.__isUserSettingDisabled) {
            this.__restoreDisabledTo = this.disabled;
          }
          if (this.disabled === false && this._requestedToBeDisabled === true) {
            this.__internalSetDisabled(true);
          }
        }
      }
    };

  const DisabledMixin = dedupeMixin(DisabledMixinImplementation);

  /* eslint-disable class-methods-use-this */

  /**
   * @typedef {import('../types/SlotMixinTypes').SlotMixin} SlotMixin
   * @typedef {import('../types/SlotMixinTypes').SlotsMap} SlotsMap
   */

  /**
   * @type {SlotMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<HTMLElement>} superclass
   */
  const SlotMixinImplementation = superclass =>
    // eslint-disable-next-line no-unused-vars, no-shadow
    class extends superclass {
      /**
       * @return {SlotsMap}
       */
      get slots() {
        return {};
      }

      constructor() {
        super();
        /** @private */
        this.__privateSlots = new Set(null);
      }

      connectedCallback() {
        // @ts-ignore checking this in case we pass LitElement, found no good way to type this...
        if (super.connectedCallback) {
          // @ts-ignore checking this in case we pass LitElement, found no good way to type this...
          super.connectedCallback();
        }
        this._connectSlotMixin();
      }

      /**
       * @protected
       */
      _connectSlotMixin() {
        if (!this.__isConnectedSlotMixin) {
          Object.keys(this.slots).forEach(slotName => {
            if (!this.querySelector(`[slot=${slotName}]`)) {
              const slotFactory = this.slots[slotName];
              const slotContent = slotFactory();
              // ignore non-elements to enable conditional slots
              if (slotContent instanceof Element) {
                slotContent.setAttribute('slot', slotName);
                this.appendChild(slotContent);
                this.__privateSlots.add(slotName);
              }
            }
          });
          this.__isConnectedSlotMixin = true;
        }
      }

      /**
       * @param {string} slotName Name of the slot
       * @return {boolean} true if given slot name been created by SlotMixin
       * @protected
       */
      _isPrivateSlot(slotName) {
        return this.__privateSlots.has(slotName);
      }
    };

  const SlotMixin = dedupeMixin(SlotMixinImplementation);

  /**
   * From https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
   * @param {string} [flavor]
   */
  function checkChrome(flavor = 'google-chrome') {
    const isChromium = /** @type {window & { chrome?: boolean}} */ (window).chrome;
    if (flavor === 'chromium') {
      return isChromium;
    }
    const winNav = window.navigator;
    const vendorName = winNav.vendor;
    const isOpera = typeof (/** @type {window & { opr?: boolean}} */ (window).opr) !== 'undefined';
    const isIEedge = winNav.userAgent.indexOf('Edge') > -1;
    const isIOSChrome = winNav.userAgent.match('CriOS');

    if (flavor === 'ios') {
      return isIOSChrome;
    }

    if (flavor === 'google-chrome') {
      return (
        isChromium !== null &&
        typeof isChromium !== 'undefined' &&
        vendorName === 'Google Inc.' &&
        isOpera === false &&
        isIEedge === false
      );
    }

    return undefined;
  }

  const browserDetection = {
    isIE11: /Trident/.test(window.navigator.userAgent),
    isChrome: checkChrome(),
    isIOSChrome: checkChrome('ios'),
    isChromium: checkChrome('chromium'),
    isMac: navigator.appVersion.indexOf('Mac') !== -1,
  };

  /* eslint-disable no-bitwise */

  const moveDownConditions = [
    Node.DOCUMENT_POSITION_PRECEDING,
    Node.DOCUMENT_POSITION_CONTAINS,
    Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING,
  ];

  /**
   * @desc Let the order of adding ids to aria element by DOM order, so that the screen reader
   * respects visual order when reading:
   * https://developers.google.com/web/fundamentals/accessibility/focus/dom-order-matters
   * @param {HTMLElement[]} descriptionElements - holds references to description or label elements whose
   * id should be returned
   * @param {Object} opts
   * @param {boolean} [opts.reverse]
   * @returns {HTMLElement[]} sorted set of elements based on dom order
   */
  function getAriaElementsInRightDomOrder(descriptionElements, { reverse } = {}) {
    /**
     * @param {HTMLElement} a
     * @param {HTMLElement} b
     * @return {-1|1}
     */
    const putPrecedingSiblingsAndLocalParentsFirst = (a, b) => {
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
      const pos = a.compareDocumentPosition(b);

      // Unfortunately, for IE, we have to switch the order (?)
      if (moveDownConditions.includes(pos)) {
        return browserDetection.isIE11 ? -1 : 1;
      }
      return browserDetection.isIE11 ? 1 : -1;
    };

    const descriptionEls = descriptionElements.filter(el => el); // filter out null references
    descriptionEls.sort(putPrecedingSiblingsAndLocalParentsFirst);
    if (reverse) {
      descriptionEls.reverse();
    }
    return descriptionEls;
  }

  /**
   * A modelValue can demand a certain type (Date, Number, Iban etc.). A correct type will always be
   * translatable into a String representation (the value presented to the end user) via the
   * `formatter`. When the type is not valid (usually as a consequence of a user typing in an invalid
   * or incomplete viewValue), the current truth is captured in the `Unparseable` type.
   * For example: a viewValue can't be parsed (for instance 'foo' when the type should be Number).

   * The model(value) concept as implemented in lion-web is conceptually comparable to those found in
   * popular frameworks like Angular and Vue.

   * The Unparseable type is an addition on top of this that mainly is added for the following two
   * purposes:
   * - restoring user sessions
   * - realtime updated with all value changes
   */
  class Unparseable {
    /** @param {string} value */
    constructor(value) {
      this.type = 'unparseable';
      this.viewValue = value;
    }

    toString() {
      return JSON.stringify({ type: this.type, viewValue: this.viewValue });
    }
  }

  /**
   * @typedef {import('@lion/core').LitElement} LitElement
   * @typedef {import('../../types/FormControlMixinTypes').FormControlHost} FormControlHost
   * @typedef {import('../../types/registration/FormRegisteringMixinTypes').FormRegisteringMixin} FormRegisteringMixin
   * @typedef {import('../../types/registration/FormRegisteringMixinTypes').FormRegisteringHost} FormRegisteringHost
   * @typedef {import('../../types/registration/FormRegistrarMixinTypes').ElementWithParentFormGroup} ElementWithParentFormGroup
   * @typedef {import('../../types/registration/FormRegistrarMixinTypes').FormRegistrarHost} FormRegistrarHost
   */

  /**
   * #FormRegisteringMixin:
   *
   * This Mixin registers a form element to a Registrar
   *
   * @type {FormRegisteringMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<LitElement>} superclass
   */
  const FormRegisteringMixinImplementation = superclass =>
    class extends superclass {
      constructor() {
        super();
        /** @type {FormRegistrarHost | undefined} */
        this._parentFormGroup = undefined;
      }

      connectedCallback() {
        super.connectedCallback();
        this.dispatchEvent(
          new CustomEvent('form-element-register', {
            detail: { element: this },
            bubbles: true,
          }),
        );
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._parentFormGroup) {
          this._parentFormGroup.removeFormElement(/** @type {* & FormRegisteringHost} */ (this));
        }
      }
    };

  const FormRegisteringMixin = dedupeMixin(FormRegisteringMixinImplementation);

  /**
   * @typedef {import('@lion/core').TemplateResult} TemplateResult
   * @typedef {import('@lion/core').CSSResult} CSSResult
   * @typedef {import('@lion/core').CSSResultArray} CSSResultArray
   * @typedef {import('@lion/core').nothing} nothing
   * @typedef {import('@lion/core/types/SlotMixinTypes').SlotsMap} SlotsMap
   * @typedef {import('./validate/LionValidationFeedback').LionValidationFeedback} LionValidationFeedback
   * @typedef {import('../types/choice-group/ChoiceInputMixinTypes').ChoiceInputHost} ChoiceInputHost
   * @typedef {import('../types/FormControlMixinTypes.js').FormControlHost} FormControlHost
   * @typedef {import('../types/FormControlMixinTypes.js').HTMLElementWithValue} HTMLElementWithValue
   * @typedef {import('../types/FormControlMixinTypes.js').FormControlMixin} FormControlMixin
   * @typedef {import('../types/FormControlMixinTypes.js').ModelValueEventDetails} ModelValueEventDetails
   */

  /**
   * Generates random unique identifier (for dom elements)
   * @param {string} prefix
   */
  function uuid(prefix) {
    return `${prefix}-${Math.random().toString(36).substr(2, 10)}`;
  }

  /**
   * #FormControlMixin :
   *
   * This Mixin is a shared fundament for all form components, it's applied on:
   * - LionField (which is extended to LionInput, LionTextarea, LionSelect etc. etc.)
   * - LionFieldset (which is extended to LionRadioGroup, LionCheckboxGroup, LionForm)
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   * @type {FormControlMixin}
   */
  const FormControlMixinImplementation = superclass =>
    // eslint-disable-next-line no-shadow, no-unused-vars
    class FormControlMixin extends FormRegisteringMixin(DisabledMixin(SlotMixin(superclass))) {
      /** @type {any} */
      static get properties() {
        return {
          /**
           * The name the element will be registered on to the .formElements collection
           * of the parent.
           */
          name: {
            type: String,
            reflect: true,
          },
          /**
           * A Boolean attribute which, if present, indicates that the user should not be able to edit
           * the value of the input. The difference between disabled and readonly is that read-only
           * controls can still function, whereas disabled controls generally do not function as
           * controls until they are enabled.
           *
           * (From: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-readonly)
           */
          readOnly: {
            type: Boolean,
            attribute: 'readonly',
            reflect: true,
          },
          /**
           * The label text for the input node.
           * When no light dom defined via [slot=label], this value will be used
           */
          label: String, // FIXME: { attribute: false } breaks a bunch of tests, but shouldn't...
          /**
           * The helpt text for the input node.
           * When no light dom defined via [slot=help-text], this value will be used
           */
          helpText: {
            type: String,
            attribute: 'help-text',
          },

          /**
           * The model value is the result of the parser function(when available).
           * It should be considered as the internal value used for validation and reasoning/logic.
           * The model value is 'ready for consumption' by the outside world (think of a Date
           * object or a float). The modelValue can(and is recommended to) be used as both input
           * value and output value of the `LionField`.
           *
           * Examples:
           * - For a date input: a String '20/01/1999' will be converted to new Date('1999/01/20')
           * - For a number input: a formatted String '1.234,56' will be converted to a Number:
           *   1234.56
           */
          modelValue: { attribute: false },

          /**
           * Contains all elements that should end up in aria-labelledby of `._inputNode`
           */
          _ariaLabelledNodes: { attribute: false },
          /**
           * Contains all elements that should end up in aria-describedby of `._inputNode`
           */
          _ariaDescribedNodes: { attribute: false },
          /**
           * Based on the role, details of handling model-value-changed repropagation differ.
           */
          _repropagationRole: { attribute: false },
          /**
           * By default, a field with _repropagationRole 'choice-group' will act as an
           * 'endpoint'. This means it will be considered as an individual field: for
           * a select, individual options will not be part of the formPath. They
           * will.
           * Similarly, components that (a11y wise) need to be fieldsets, but 'interaction wise'
           * (from Application Developer perspective) need to be more like fields
           * (think of an amount-input with a currency select box next to it), can set this
           * to true to hide private internals in the formPath.
           */
          _isRepropagationEndpoint: { attribute: false },
        };
      }

      /**
       * @return {string}
       */
      get label() {
        return this.__label || (this._labelNode && this._labelNode.textContent) || '';
      }

      /**
       * @param {string} newValue
       */
      set label(newValue) {
        const oldValue = this.label;
        /** @type {string} */
        this.__label = newValue;
        this.requestUpdate('label', oldValue);
      }

      /**
       * @return {string}
       */
      get helpText() {
        return this.__helpText || (this._helpTextNode && this._helpTextNode.textContent) || '';
      }

      /**
       * @param {string} newValue
       */
      set helpText(newValue) {
        const oldValue = this.helpText;
        /** @type {string} */
        this.__helpText = newValue;
        this.requestUpdate('helpText', oldValue);
      }

      /**
       * @return {string}
       */
      get fieldName() {
        return this.__fieldName || this.label || this.name || '';
      }

      /**
       * @param {string} value
       */
      set fieldName(value) {
        /** @type {string} */
        this.__fieldName = value;
      }

      /**
       * @type {SlotsMap}
       */
      get slots() {
        return {
          ...super.slots,
          label: () => {
            const label = document.createElement('label');
            label.textContent = this.label;
            return label;
          },
          'help-text': () => {
            const helpText = document.createElement('div');
            helpText.textContent = this.helpText;
            return helpText;
          },
        };
      }

      /** @protected */
      get _inputNode() {
        return /** @type {HTMLElementWithValue} */ (this.__getDirectSlotChild('input'));
      }

      get _labelNode() {
        return /** @type {HTMLElement} */ (this.__getDirectSlotChild('label'));
      }

      get _helpTextNode() {
        return /** @type {HTMLElement} */ (this.__getDirectSlotChild('help-text'));
      }

      /**
       * @protected
       */
      get _feedbackNode() {
        return /** @type {LionValidationFeedback} */ (this.__getDirectSlotChild('feedback'));
      }

      constructor() {
        super();
        /** @type {string} */
        this.name = '';
        /** @type {string} */
        this._inputId = uuid(this.localName);
        /** @type {HTMLElement[]} */
        this._ariaLabelledNodes = [];
        /** @type {HTMLElement[]} */
        this._ariaDescribedNodes = [];
        /** @type {'child'|'choice-group'|'fieldset'} */
        this._repropagationRole = 'child';
        this._isRepropagationEndpoint = false;
        /** @private */
        this.__label = '';
        this.addEventListener(
          'model-value-changed',
          /** @type {EventListenerOrEventListenerObject} */ (this.__repropagateChildrenValues),
        );
        /** @type {EventListener} */
        this._onLabelClick = this._onLabelClick.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        this._enhanceLightDomClasses();
        this._enhanceLightDomA11y();
        this._triggerInitialModelValueChangedEvent();

        if (this._labelNode) {
          this._labelNode.addEventListener('click', this._onLabelClick);
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._labelNode) {
          this._labelNode.removeEventListener('click', this._onLabelClick);
        }
      }

      /** @param {import('@lion/core').PropertyValues } changedProperties */
      updated(changedProperties) {
        super.updated(changedProperties);

        if (changedProperties.has('_ariaLabelledNodes')) {
          this.__reflectAriaAttr(
            'aria-labelledby',
            this._ariaLabelledNodes,
            this.__reorderAriaLabelledNodes,
          );
        }

        if (changedProperties.has('_ariaDescribedNodes')) {
          this.__reflectAriaAttr(
            'aria-describedby',
            this._ariaDescribedNodes,
            this.__reorderAriaDescribedNodes,
          );
        }

        if (changedProperties.has('label') && this._labelNode) {
          this._labelNode.textContent = this.label;
        }

        if (changedProperties.has('helpText') && this._helpTextNode) {
          this._helpTextNode.textContent = this.helpText;
        }

        if (changedProperties.has('name')) {
          this.dispatchEvent(
            new CustomEvent('form-element-name-changed', {
              detail: { oldName: changedProperties.get('name'), newName: this.name },
              bubbles: true,
            }),
          );
        }
      }

      /** @protected */
      _triggerInitialModelValueChangedEvent() {
        this._dispatchInitialModelValueChangedEvent();
      }

      /** @protected */
      _enhanceLightDomClasses() {
        if (this._inputNode) {
          this._inputNode.classList.add('form-control');
        }
      }

      /** @protected */
      _enhanceLightDomA11y() {
        const { _inputNode, _labelNode, _helpTextNode, _feedbackNode } = this;

        if (_inputNode) {
          _inputNode.id = _inputNode.id || this._inputId;
        }
        if (_labelNode) {
          _labelNode.setAttribute('for', this._inputId);
          this.addToAriaLabelledBy(_labelNode, { idPrefix: 'label' });
        }
        if (_helpTextNode) {
          this.addToAriaDescribedBy(_helpTextNode, { idPrefix: 'help-text' });
        }
        if (_feedbackNode) {
          // Generic focus/blur handling that works for both Fields/FormGroups
          this.addEventListener('focusin', () => {
            _feedbackNode.setAttribute('aria-live', 'polite');
          });
          this.addEventListener('focusout', () => {
            _feedbackNode.setAttribute('aria-live', 'assertive');
          });

          this.addToAriaDescribedBy(_feedbackNode, { idPrefix: 'feedback' });
        }
        this._enhanceLightDomA11yForAdditionalSlots();
      }

      /**
       * Enhances additional slots(prefix, suffix, before, after) defined by developer.
       *
       * When boolean attribute data-label or data-description is found,
       * the slot element will be connected to the input via aria-labelledby or aria-describedby
       * @param {string[]} additionalSlots
       * @protected
       */
      _enhanceLightDomA11yForAdditionalSlots(
        additionalSlots = ['prefix', 'suffix', 'before', 'after'],
      ) {
        additionalSlots.forEach(additionalSlot => {
          const element = this.__getDirectSlotChild(additionalSlot);
          if (element) {
            if (element.hasAttribute('data-label')) {
              this.addToAriaLabelledBy(element, { idPrefix: additionalSlot });
            }
            if (element.hasAttribute('data-description')) {
              this.addToAriaDescribedBy(element, { idPrefix: additionalSlot });
            }
          }
        });
      }

      /**
       * Will handle help text, validation feedback and character counter,
       * prefix/suffix/before/after (if they contain data-description flag attr).
       * Also, contents of id references that will be put in the <lion-field>._ariaDescribedby property
       * from an external context, will be read by a screen reader.
       * @param {string} attrName
       * @param {HTMLElement[]} nodes
       * @param {boolean|undefined} reorder
       */
      __reflectAriaAttr(attrName, nodes, reorder) {
        if (this._inputNode) {
          if (reorder) {
            const insideNodes = nodes.filter(n => this.contains(n));
            const outsideNodes = nodes.filter(n => !this.contains(n));

            // eslint-disable-next-line no-param-reassign
            nodes = [...getAriaElementsInRightDomOrder(insideNodes), ...outsideNodes];
          }
          const string = nodes.map(n => n.id).join(' ');
          this._inputNode.setAttribute(attrName, string);
        }
      }

      /**
       * Default Render Result:
       * <div class="form-field__group-one">
       *   <div class="form-field__label">
       *     <slot name="label"></slot>
       *   </div>
       *   <small class="form-field__help-text">
       *     <slot name="help-text"></slot>
       *   </small>
       * </div>
       * <div class="form-field__group-two">
       *   <div class="input-group">
       *     <div class="input-group__before">
       *       <slot name="before"></slot>
       *     </div>
       *     <div class="input-group__container">
       *       <div class="input-group__prefix">
       *         <slot name="prefix"></slot>
       *       </div>
       *       <div class="input-group__input">
       *         <slot name="input"></slot>
       *       </div>
       *       <div class="input-group__suffix">
       *         <slot name="suffix"></slot>
       *       </div>
       *     </div>
       *     <div class="input-group__after">
       *       <slot name="after"></slot>
       *     </div>
       *   </div>
       *   <div class="form-field__feedback">
       *     <slot name="feedback"></slot>
       *   </div>
       * </div>
       */
      render() {
        return html`
        <div class="form-field__group-one">${this._groupOneTemplate()}</div>
        <div class="form-field__group-two">${this._groupTwoTemplate()}</div>
      `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      _groupOneTemplate() {
        return html` ${this._labelTemplate()} ${this._helpTextTemplate()} `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      _groupTwoTemplate() {
        return html` ${this._inputGroupTemplate()} ${this._feedbackTemplate()} `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _labelTemplate() {
        return html`
        <div class="form-field__label">
          <slot name="label"></slot>
        </div>
      `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _helpTextTemplate() {
        return html`
        <small class="form-field__help-text">
          <slot name="help-text"></slot>
        </small>
      `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      _inputGroupTemplate() {
        return html`
        <div class="input-group">
          ${this._inputGroupBeforeTemplate()}
          <div class="input-group__container">
            ${this._inputGroupPrefixTemplate()} ${this._inputGroupInputTemplate()}
            ${this._inputGroupSuffixTemplate()}
          </div>
          ${this._inputGroupAfterTemplate()}
        </div>
      `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _inputGroupBeforeTemplate() {
        return html`
        <div class="input-group__before">
          <slot name="before"></slot>
        </div>
      `;
      }

      /**
       * @return {TemplateResult | nothing}
       * @protected
       */
      _inputGroupPrefixTemplate() {
        return !Array.from(this.children).find(child => child.slot === 'prefix')
          ? nothing
          : html`
            <div class="input-group__prefix">
              <slot name="prefix"></slot>
            </div>
          `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _inputGroupInputTemplate() {
        return html`
        <div class="input-group__input">
          <slot name="input"></slot>
        </div>
      `;
      }

      /**
       * @return {TemplateResult | nothing}
       * @protected
       */
      _inputGroupSuffixTemplate() {
        return !Array.from(this.children).find(child => child.slot === 'suffix')
          ? nothing
          : html`
            <div class="input-group__suffix">
              <slot name="suffix"></slot>
            </div>
          `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _inputGroupAfterTemplate() {
        return html`
        <div class="input-group__after">
          <slot name="after"></slot>
        </div>
      `;
      }

      /**
       * @return {TemplateResult}
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _feedbackTemplate() {
        return html`
        <div class="form-field__feedback">
          <slot name="feedback"></slot>
        </div>
      `;
      }

      /**
       * @param {any} modelValue
       * @return {boolean}
       * @protected
       */
      _isEmpty(modelValue = /** @type {any} */ (this).modelValue) {
        let value = modelValue;
        if (/** @type {any} */ (this).modelValue instanceof Unparseable) {
          value = /** @type {any} */ (this).modelValue.viewValue;
        }

        // Checks for empty platform types: Objects, Arrays, Dates
        if (typeof value === 'object' && value !== null && !(value instanceof Date)) {
          return !Object.keys(value).length;
        }

        // eslint-disable-next-line no-mixed-operators
        // Checks for empty platform types: Numbers, Booleans
        const isNumberValue = typeof value === 'number' && (value === 0 || Number.isNaN(value));
        const isBooleanValue = typeof value === 'boolean' && value === false;

        return !value && !isNumberValue && !isBooleanValue;
      }

      /**
       * All CSS below is written from a generic mindset, following BEM conventions:
       * https://en.bem.info/methodology/
       * Although the CSS and HTML are implemented by the component, they should be regarded as
       * totally decoupled.
       *
       * Not only does this force us to write better structured css, it also allows for future
       * reusability in many different ways like:
       *  - disabling shadow DOM for a component (for water proof encapsulation can be combined with
       *    a build step)
       *  - easier translation to more flexible, WebComponents agnostic solutions like JSS
       *    (allowing extends, mixins, reasoning, IDE integration, tree shaking etc.)
       *  - export to a CSS module for reuse in an outer context
       *
       *
       * Please note that the HTML structure is purposely 'loose', allowing multiple design systems
       * to be compatible
       * with the CSS component.
       * Note that every occurence of '::slotted(*)' can be rewritten to '> *' for use in an other
       * context
       */

      /**
       * {block} .form-field
       *
       * Structure:
       * - {element}  .form-field__label : a wrapper element around the projected label
       * - {element}  .form-field__help-text (optional) : a wrapper element around the projected
       *               help-text
       * - {block}    .input-group : a container around the input element, including prefixes and
       *               suffixes
       * - {element}  .form-field__feedback (optional) : a wrapper element around the projected
       *               (validation) feedback message
       *
       * Modifiers:
       * - {state} [disabled] when .form-control (<input>, <textarea> etc.) has disabled set
       *            to true
       * - {state} [filled] whether <input> has a value
       * - {state} [touched] whether the user had blurred the field once
       * - {state} [dirty] whether the value has changed since initial value
       *
       * TODO: update states below
       * These classes are now attributes. Check them agains the new attribute names inside ValidateMixin
       * and InteractionStateMixin. Some states got renamed. Make sure to use the correct ones!
       * - {state} .state-focused: when .form-control (<input>, <textarea> etc.) <input> has focus
       * - {state} .state-invalid: when input has error(s) (regardless of whether they should be
       *            shown to the user)
       * - {state} .state-error: when input has error(s) and this/these should be shown to the user
       * - {state} .state-warning: when input has warning(s) and this/these should be shown to the
       *            user
       * - {state} .state-info: when input has info feedback message(s) and this/these should be shown
       *            to the user
       * - {state} .state-success: when input has success feedback message(s) and this/these should be
       *            shown to the user
       */

      /**
       * {block} .input-group
       *
       * Structure:
       * - {element} .input-group__before (optional) : a prefix that resides outside the container
       * - {element} .input-group__container : an inner container: this element contains all styling
       *  - {element} .input-group__prefix (optional) : a prefix that resides in the container,
       *               allowing it to be detectable as a :first-child
       *  - {element} .input-group__input : a wrapper around the form-control component
       *   - {block} .form-control : the actual input element (input/select/textarea)
       *  - {element} .input-group__suffix (optional) : a suffix that resides inside the container,
       *               allowing it to be detectable as a :last-child
       *  - {element} .input-group__bottom (optional) : placeholder element for additional styling
       *               (like an animated line for material design input)
       * - {element} .input-group__after (optional) :  a suffix that resides outside the container
       */
      static get styles() {
        return [
          css`
          /**********************
            {block} .form-field
           ********************/

          :host {
            display: block;
          }

          :host([hidden]) {
            display: none;
          }

          :host([disabled]) {
            pointer-events: none;
          }

          :host([disabled]) .form-field__label ::slotted(*),
          :host([disabled]) .form-field__help-text ::slotted(*) {
            color: var(--disabled-text-color, #767676);
          }

          /***********************
            {block} .input-group
           *********************/

          .input-group__container {
            display: flex;
          }

          .input-group__input {
            flex: 1;
            display: flex;
          }

          /***** {state} :disabled *****/
          :host([disabled]) .input-group ::slotted([slot='input']) {
            color: var(--disabled-text-color, #767676);
          }

          /***********************
            {block} .form-control
           **********************/

          .input-group__container > .input-group__input ::slotted(.form-control) {
            flex: 1 1 auto;
            margin: 0; /* remove input margin in Safari */
            font-size: 100%; /* normalize default input font-size */
          }
        `,
        ];
      }

      /**
       * This function exposes descripion elements that a FormGroup should expose to its
       * children. See FormGroupMixin.__getAllDescriptionElementsInParentChain()
       * @return {Array.<HTMLElement>}
       * @protected
       */
      // Returns dom references to all elements that should be referred to by field(s)
      _getAriaDescriptionElements() {
        return [this._helpTextNode, this._feedbackNode];
      }

      /**
       * Meant for Application Developers wanting to add to aria-labelledby attribute.
       * @param {HTMLElement} element
       * @param {{idPrefix?:string; reorder?: boolean}} customConfig
       */
      addToAriaLabelledBy(element, { idPrefix = '', reorder = true } = {}) {
        // eslint-disable-next-line no-param-reassign
        element.id = element.id || `${idPrefix}-${this._inputId}`;
        if (!this._ariaLabelledNodes.includes(element)) {
          this._ariaLabelledNodes = [...this._ariaLabelledNodes, element];
          // This value will be read when we need to reflect to attr
          /** @type {boolean} */
          this.__reorderAriaLabelledNodes = Boolean(reorder);
        }
      }

      /**
       * Meant for Application Developers wanting to delete from aria-labelledby attribute.
       * @param {HTMLElement} element
       */
      removeFromAriaLabelledBy(element) {
        if (this._ariaLabelledNodes.includes(element)) {
          this._ariaLabelledNodes.splice(this._ariaLabelledNodes.indexOf(element), 1);
          this._ariaLabelledNodes = [...this._ariaLabelledNodes];

          // This value will be read when we need to reflect to attr
          /** @type {boolean} */
          this.__reorderAriaLabelledNodes = false;
        }
      }

      /**
       * Meant for Application Developers wanting to add to aria-describedby attribute.
       * @param {HTMLElement} element
       * @param {{idPrefix?:string; reorder?: boolean}} customConfig
       */
      addToAriaDescribedBy(element, { idPrefix = '', reorder = true } = {}) {
        // eslint-disable-next-line no-param-reassign
        element.id = element.id || `${idPrefix}-${this._inputId}`;
        if (!this._ariaDescribedNodes.includes(element)) {
          this._ariaDescribedNodes = [...this._ariaDescribedNodes, element];
          // This value will be read when we need to reflect to attr
          /** @type {boolean} */
          this.__reorderAriaDescribedNodes = Boolean(reorder);
        }
      }

      /**
       * Meant for Application Developers wanting to delete from aria-describedby attribute.
       * @param {HTMLElement} element
       */
      removeFromAriaDescribedBy(element) {
        if (this._ariaDescribedNodes.includes(element)) {
          this._ariaDescribedNodes.splice(this._ariaDescribedNodes.indexOf(element), 1);
          this._ariaDescribedNodes = [...this._ariaDescribedNodes];
          // This value will be read when we need to reflect to attr
          /** @type {boolean} */
          this.__reorderAriaLabelledNodes = false;
        }
      }

      /**
       * @param {string} slotName
       * @return {HTMLElement | undefined}
       */
      __getDirectSlotChild(slotName) {
        return /** @type {HTMLElement[]} */ (Array.from(this.children)).find(
          el => el.slot === slotName,
        );
      }

      _dispatchInitialModelValueChangedEvent() {
        // When we are not a fieldset / choice-group, we don't need to wait for our children
        // to send a unified event
        if (this._repropagationRole === 'child') {
          return;
        }

        // Initially we don't repropagate model-value-changed events coming
        // from children. On firstUpdated we re-dispatch this event to maintain
        // 'count consistency' (to not confuse the application developer with a
        // large number of initial events). Initially the source field will not
        // be part of the formPath but afterwards it will.
        /** @type {boolean} */
        this.__repropagateChildrenInitialized = true;
        this.dispatchEvent(
          new CustomEvent('model-value-changed', {
            bubbles: true,
            detail: /** @type {ModelValueEventDetails} */ ({
              formPath: [this],
              initialize: true,
              isTriggeredByUser: false,
            }),
          }),
        );
      }

      /**
       * @param {CustomEvent} ev
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this, no-unused-vars
      _onBeforeRepropagateChildrenValues(ev) {}

      /**
       * @param {CustomEvent} ev
       */
      __repropagateChildrenValues(ev) {
        // Allows sub classes to internally listen to the children change events
        // (before stopImmediatePropagation is called below).
        this._onBeforeRepropagateChildrenValues(ev);
        // Normalize target, we also might get it from 'portals' (rich select)
        const target = (ev.detail && ev.detail.element) || ev.target;
        const isEndpoint =
          this._isRepropagationEndpoint || this._repropagationRole === 'choice-group';

        // Prevent eternal loops after we sent the event below.
        if (target === this) {
          return;
        }

        // A. Stop sibling handlers
        //
        // Make sure our sibling event listeners (added by Application developers) will not get
        // the child model-value-changed event, but the repropagated one at the bottom of this
        // method
        ev.stopImmediatePropagation();

        // B1. Are we still initializing? If so, halt...
        //
        // Stop repropagating children events before firstUpdated and make sure we de not
        // repropagate init events of our children (we already sent our own
        // initial model-value-change event in firstUpdated)
        const isGroup = this._repropagationRole !== 'child'; // => fieldset or choice-group
        const isSelfInitializing = isGroup && !this.__repropagateChildrenInitialized;
        const isChildGroupInitializing = ev.detail && ev.detail.initialize;
        if (isSelfInitializing || isChildGroupInitializing) {
          return;
        }

        // B2. Are we a single choice choice-group? If so, halt when target unchecked
        // and something else is checked, meaning we will get
        // another model-value-changed dispatch for the checked target
        //
        // We only send the checked changed up (not the unchecked). In this way a choice group
        // (radio-group, checkbox-group, select/listbox) acts as an 'endpoint' (a single Field)
        // just like the native <select>
        if (!this._repropagationCondition(target)) {
          return;
        }

        // C1. We are ready to dispatch. Create a formPath
        //
        // Compute the formPath. Choice groups are regarded 'end points'
        let parentFormPath = [];
        if (!isEndpoint) {
          parentFormPath = (ev.detail && ev.detail.formPath) || [target];
        }
        const formPath = [...parentFormPath, this];

        // C2. Finally, redispatch a fresh model-value-changed event from our host, consumable
        // for an Application Developer
        //
        // Since for a11y everything needs to be in lightdom, we don't add 'composed:true'
        this.dispatchEvent(
          new CustomEvent('model-value-changed', {
            bubbles: true,
            detail: /** @type {ModelValueEventDetails} */ ({
              formPath,
              isTriggeredByUser: Boolean(ev.detail?.isTriggeredByUser),
            }),
          }),
        );
      }

      /**
       * Based on provided target, this condition determines whether received model-value-changed
       * event should be repropagated
       * @param {FormControlHost} target
       * @protected
       * @overridable
       */
      // eslint-disable-next-line class-methods-use-this
      _repropagationCondition(target) {
        return Boolean(target);
      }

      /**
       * @overridable
       * A Subclasser should only override this method if the interactive element
       * ([slot=input]) is not a native element(like input, textarea, select)
       * that already receives focus on label click.
       *
       * @example
       * _onLabelClick() {
       *   this._invokerNode.focus();
       * }
       * @protected
       */
      // eslint-disable-next-line class-methods-use-this
      _onLabelClick() {}
    };

  const FormControlMixin = dedupeMixin(FormControlMixinImplementation);

  /**
   * @typedef {import('../types/FocusMixinTypes').FocusMixin} FocusMixin
   * @type {FocusMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   */
  const FocusMixinImplementation = superclass =>
    class FocusMixin extends FormControlMixin(superclass) {
      /** @type {any} */
      static get properties() {
        return {
          focused: {
            type: Boolean,
            reflect: true,
          },
        };
      }

      constructor() {
        super();
        this.focused = false;
      }

      connectedCallback() {
        super.connectedCallback();
        this.__registerEventsForFocusMixin();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.__teardownEventsForFocusMixin();
      }

      focus() {
        const native = this._inputNode;
        if (native) {
          native.focus();
        }
      }

      blur() {
        const native = this._inputNode;
        if (native) {
          native.blur();
        }
      }

      /**
       * @private
       */
      __onFocus() {
        this.focused = true;
      }

      /**
       * @private
       */
      __onBlur() {
        this.focused = false;
      }

      /**
       * @private
       */
      __registerEventsForFocusMixin() {
        /**
         * focus
         * @param {Event} ev
         */
        this.__redispatchFocus = ev => {
          ev.stopPropagation();
          this.dispatchEvent(new Event('focus'));
        };
        this._inputNode.addEventListener('focus', this.__redispatchFocus);

        /**
         * blur
         * @param {Event} ev
         */
        this.__redispatchBlur = ev => {
          ev.stopPropagation();
          this.dispatchEvent(new Event('blur'));
        };
        this._inputNode.addEventListener('blur', this.__redispatchBlur);

        /**
         * focusin
         * @param {Event} ev
         */
        this.__redispatchFocusin = ev => {
          ev.stopPropagation();
          this.__onFocus();
          this.dispatchEvent(new Event('focusin', { bubbles: true, composed: true }));
        };
        this._inputNode.addEventListener('focusin', this.__redispatchFocusin);

        /**
         * focusout
         * @param {Event} ev
         */
        this.__redispatchFocusout = ev => {
          ev.stopPropagation();
          this.__onBlur();
          this.dispatchEvent(new Event('focusout', { bubbles: true, composed: true }));
        };
        this._inputNode.addEventListener('focusout', this.__redispatchFocusout);
      }

      /**
       * @private
       */
      __teardownEventsForFocusMixin() {
        this._inputNode.removeEventListener(
          'focus',
          /** @type {EventListenerOrEventListenerObject} */ (this.__redispatchFocus),
        );
        this._inputNode.removeEventListener(
          'blur',
          /** @type {EventListenerOrEventListenerObject} */ (this.__redispatchBlur),
        );
        this._inputNode.removeEventListener(
          'focusin',
          /** @type {EventListenerOrEventListenerObject} */ (this.__redispatchFocusin),
        );
        this._inputNode.removeEventListener(
          'focusout',
          /** @type {EventListenerOrEventListenerObject} */ (this.__redispatchFocusout),
        );
      }
    };

  const FocusMixin = dedupeMixin(FocusMixinImplementation);

  const sym = Symbol.for('lion::SingletonManagerClassStorage');

  class SingletonManagerClass {
    constructor() {
      /** protected */
      this._map = window[sym] ? window[sym] : (window[sym] = new Map());
    }

    /**
     * Ignores already existing keys (e.g. it will not override)
     *
     * @param {string} key
     * @param {any} value
     */
    set(key, value) {
      if (!this.has(key)) {
        this._map.set(key, value);
      }
    }

    /**
     * @param {string} key
     * @returns
     */
    get(key) {
      return this._map.get(key);
    }

    /**
     * @param {string} key
     */
    has(key) {
      return this._map.has(key);
    }
  }

  const singletonManager = new SingletonManagerClass();

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  // @flow
  var LONG = 'long';
  var SHORT = 'short';
  var NARROW = 'narrow';
  var NUMERIC = 'numeric';
  var TWODIGIT = '2-digit';

  /**
   * formatting information
   **/
  var formatMessageFormats = {
    number: {
      decimal: {
        style: 'decimal'
      },
      integer: {
        style: 'decimal',
        maximumFractionDigits: 0
      },
      currency: {
        style: 'currency',
        currency: 'USD'
      },
      percent: {
        style: 'percent'
      },
      default: {
        style: 'decimal'
      }
    },
    date: {
      short: {
        month: NUMERIC,
        day: NUMERIC,
        year: TWODIGIT
      },
      medium: {
        month: SHORT,
        day: NUMERIC,
        year: NUMERIC
      },
      long: {
        month: LONG,
        day: NUMERIC,
        year: NUMERIC
      },
      full: {
        month: LONG,
        day: NUMERIC,
        year: NUMERIC,
        weekday: LONG
      },
      default: {
        month: SHORT,
        day: NUMERIC,
        year: NUMERIC
      }
    },
    time: {
      short: {
        hour: NUMERIC,
        minute: NUMERIC
      },
      medium: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC
      },
      long: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC,
        timeZoneName: SHORT
      },
      full: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC,
        timeZoneName: SHORT
      },
      default: {
        hour: NUMERIC,
        minute: NUMERIC,
        second: NUMERIC
      }
    },
    duration: {
      default: {
        hours: {
          minimumIntegerDigits: 1,
          maximumFractionDigits: 0
        },
        minutes: {
          minimumIntegerDigits: 2,
          maximumFractionDigits: 0
        },
        seconds: {
          minimumIntegerDigits: 2,
          maximumFractionDigits: 3
        }
      }
    },
    parseNumberPattern: function (pattern/*: ?string */) {
      if (!pattern) return
      var options = {};
      var currency = pattern.match(/\b[A-Z]{3}\b/i);
      var syms = pattern.replace(/[^¤]/g, '').length;
      if (!syms && currency) syms = 1;
      if (syms) {
        options.style = 'currency';
        options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name';
        options.currency = currency ? currency[0].toUpperCase() : 'USD';
      } else if (pattern.indexOf('%') >= 0) {
        options.style = 'percent';
      }
      if (!/[@#0]/.test(pattern)) return options.style ? options : undefined
      options.useGrouping = pattern.indexOf(',') >= 0;
      if (/E\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {
        var size = pattern.replace(/E\+?[@#0]+|[^@#0]/gi, '');
        options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21);
        options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21);
      } else {
        var parts = pattern.replace(/[^#0.]/g, '').split('.');
        var integer = parts[0];
        var n = integer.length - 1;
        while (integer[n] === '0') --n;
        options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21);
        var fraction = parts[1] || '';
        n = 0;
        while (fraction[n] === '0') ++n;
        options.minimumFractionDigits = Math.min(Math.max(n, 0), 20);
        while (fraction[n] === '#') ++n;
        options.maximumFractionDigits = Math.min(Math.max(n, 0), 20);
      }
      return options
    },
    parseDatePattern: function (pattern/*: ?string */) {
      if (!pattern) return
      var options = {};
      for (var i = 0; i < pattern.length;) {
        var current = pattern[i];
        var n = 1;
        while (pattern[++i] === current) ++n;
        switch (current) {
          case 'G':
            options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
            break
          case 'y':
          case 'Y':
            options.year = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 'M':
          case 'L':
            n = Math.min(Math.max(n - 1, 0), 4);
            options.month = [ NUMERIC, TWODIGIT, SHORT, LONG, NARROW ][n];
            break
          case 'E':
          case 'e':
          case 'c':
            options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT;
            break
          case 'd':
          case 'D':
            options.day = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 'h':
          case 'K':
            options.hour12 = true;
            options.hour = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 'H':
          case 'k':
            options.hour12 = false;
            options.hour = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 'm':
            options.minute = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 's':
          case 'S':
            options.second = n === 2 ? TWODIGIT : NUMERIC;
            break
          case 'z':
          case 'Z':
          case 'v':
          case 'V':
            options.timeZoneName = n === 1 ? SHORT : LONG;
            break
        }
      }
      return Object.keys(options).length ? options : undefined
    }
  };

  // @flow
  // "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
  // assumes normalized language tags, and matches in a case sensitive manner
  var lookupClosestLocale = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {
    if (typeof locale === 'string' && available[locale]) return locale
    var locales = [].concat(locale || []);
    for (var l = 0, ll = locales.length; l < ll; ++l) {
      var current = locales[l].split('-');
      while (current.length) {
        var candidate = current.join('-');
        if (available[candidate]) return candidate
        current.pop();
      }
    }
  };

  // @flow

  /*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */
  var zero = 'zero', one = 'one', two = 'two', few = 'few', many = 'many', other = 'other';
  var f = [
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return 0 <= n && n <= 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var n = +s;
      return i === 0 || n === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 0 ? zero
        : n === 1 ? one
        : n === 2 ? two
        : 3 <= n % 100 && n % 100 <= 10 ? few
        : 11 <= n % 100 && n % 100 <= 99 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return i === 1 && v === 0 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n % 10 === 1 && n % 100 !== 11 ? one
        : (2 <= n % 10 && n % 10 <= 4) && (n % 100 < 12 || 14 < n % 100) ? few
        : n % 10 === 0 || (5 <= n % 10 && n % 10 <= 9) || (11 <= n % 100 && n % 100 <= 14) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n % 10 === 1 && (n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91) ? one
        : n % 10 === 2 && (n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92) ? two
        : ((3 <= n % 10 && n % 10 <= 4) || n % 10 === 9) && ((n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100)) ? few
        : n !== 0 && n % 1000000 === 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var f = +(s + '.').split('.')[1];
      return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
        : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) || (2 <= f % 10 && f % 10 <= 4) && (f % 100 < 12 || 14 < f % 100) ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return i === 1 && v === 0 ? one
        : (2 <= i && i <= 4) && v === 0 ? few
        : v !== 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 0 ? zero
        : n === 1 ? one
        : n === 2 ? two
        : n === 3 ? few
        : n === 6 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
      var n = +s;
      return n === 1 || t !== 0 && (i === 0 || i === 1) ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var f = +(s + '.').split('.')[1];
      return v === 0 && i % 100 === 1 || f % 100 === 1 ? one
        : v === 0 && i % 100 === 2 || f % 100 === 2 ? two
        : v === 0 && (3 <= i % 100 && i % 100 <= 4) || (3 <= f % 100 && f % 100 <= 4) ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      return i === 0 || i === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var f = +(s + '.').split('.')[1];
      return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && (i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9) || v !== 0 && (f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9) ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n === 2 ? two
        : 3 <= n && n <= 6 ? few
        : 7 <= n && n <= 10 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 || n === 11 ? one
        : n === 2 || n === 12 ? two
        : ((3 <= n && n <= 10) || (13 <= n && n <= 19)) ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return v === 0 && i % 10 === 1 ? one
        : v === 0 && i % 10 === 2 ? two
        : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few
        : v !== 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var n = +s;
      return i === 1 && v === 0 ? one
        : i === 2 && v === 0 ? two
        : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');
      return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n === 2 ? two
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 0 ? zero
        : n === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var n = +s;
      return n === 0 ? zero
        : (i === 0 || i === 1) && n !== 0 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var f = +(s + '.').split('.')[1];
      var n = +s;
      return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one
        : (2 <= n % 10 && n % 10 <= 9) && (n % 100 < 11 || 19 < n % 100) ? few
        : f !== 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var v = (s + '.').split('.')[1].length;
      var f = +(s + '.').split('.')[1];
      var n = +s;
      return n % 10 === 0 || (11 <= n % 100 && n % 100 <= 19) || v === 2 && (11 <= f % 100 && f % 100 <= 19) ? zero
        : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var f = +(s + '.').split('.')[1];
      return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      var n = +s;
      return i === 1 && v === 0 ? one
        : v !== 0 || n === 0 || n !== 1 && (1 <= n % 100 && n % 100 <= 19) ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n === 0 || (2 <= n % 100 && n % 100 <= 10) ? few
        : 11 <= n % 100 && n % 100 <= 19 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return i === 1 && v === 0 ? one
        : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
        : v === 0 && i !== 1 && (0 <= i % 10 && i % 10 <= 1) || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (12 <= i % 100 && i % 100 <= 14) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      return 0 <= i && i <= 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one
        : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few
        : v === 0 && i % 10 === 0 || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (11 <= i % 100 && i % 100 <= 14) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var n = +s;
      return i === 0 || n === 1 ? one
        : 2 <= n && n <= 10 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var f = +(s + '.').split('.')[1];
      var n = +s;
      return (n === 0 || n === 1) || i === 0 && f === 1 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      var v = (s + '.').split('.')[1].length;
      return v === 0 && i % 100 === 1 ? one
        : v === 0 && i % 100 === 2 ? two
        : v === 0 && (3 <= i % 100 && i % 100 <= 4) || v !== 0 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return (0 <= n && n <= 1) || (11 <= n && n <= 99) ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one
        : n === 2 || n === 3 ? two
        : n === 4 ? few
        : n === 6 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      return (i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8) || (i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80) ? one
        : (i % 10 === 3 || i % 10 === 4) || (i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900) ? few
        : i === 0 || i % 10 === 6 || (i % 100 === 40 || i % 100 === 60 || i % 100 === 90) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return (n % 10 === 2 || n % 10 === 3) && (n % 100 !== 12 && n % 100 !== 13) ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 || n === 3 ? one
        : n === 2 ? two
        : n === 4 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 0 || n === 7 || n === 8 || n === 9 ? zero
        : n === 1 ? one
        : n === 2 ? two
        : n === 3 || n === 4 ? few
        : n === 5 || n === 6 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n % 10 === 1 && n % 100 !== 11 ? one
        : n % 10 === 2 && n % 100 !== 12 ? two
        : n % 10 === 3 && n % 100 !== 13 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n === 2 || n === 3 ? two
        : n === 4 ? few
        : n === 6 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 || n === 5 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 11 || n === 8 || n === 80 || n === 800 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      return i === 1 ? one
        : i === 0 || ((2 <= i % 100 && i % 100 <= 20) || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var i = Math.floor(Math.abs(+s));
      return i % 10 === 1 && i % 100 !== 11 ? one
        : i % 10 === 2 && i % 100 !== 12 ? two
        : (i % 10 === 7 || i % 10 === 8) && (i % 100 !== 17 && i % 100 !== 18) ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n === 2 || n === 3 ? two
        : n === 4 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return 1 <= n && n <= 4 ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return (n === 1 || n === 5 || (7 <= n && n <= 9)) ? one
        : n === 2 || n === 3 ? two
        : n === 4 ? few
        : n === 6 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n === 1 ? one
        : n % 10 === 4 && n % 100 !== 14 ? many
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return (n % 10 === 1 || n % 10 === 2) && (n % 100 !== 11 && n % 100 !== 12) ? one
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return (n % 10 === 6 || n % 10 === 9) || n === 10 ? few
        : other
    },
    function (s/*: string | number */)/*: Rule */ {
      var n = +s;
      return n % 10 === 3 && n % 100 !== 13 ? few
        : other
    }
  ];

  var plurals = {
    af: { cardinal: f[0] },
    ak: { cardinal: f[1] },
    am: { cardinal: f[2] },
    ar: { cardinal: f[3] },
    ars: { cardinal: f[3] },
    as: { cardinal: f[2], ordinal: f[34] },
    asa: { cardinal: f[0] },
    ast: { cardinal: f[4] },
    az: { cardinal: f[0], ordinal: f[35] },
    be: { cardinal: f[5], ordinal: f[36] },
    bem: { cardinal: f[0] },
    bez: { cardinal: f[0] },
    bg: { cardinal: f[0] },
    bh: { cardinal: f[1] },
    bn: { cardinal: f[2], ordinal: f[34] },
    br: { cardinal: f[6] },
    brx: { cardinal: f[0] },
    bs: { cardinal: f[7] },
    ca: { cardinal: f[4], ordinal: f[37] },
    ce: { cardinal: f[0] },
    cgg: { cardinal: f[0] },
    chr: { cardinal: f[0] },
    ckb: { cardinal: f[0] },
    cs: { cardinal: f[8] },
    cy: { cardinal: f[9], ordinal: f[38] },
    da: { cardinal: f[10] },
    de: { cardinal: f[4] },
    dsb: { cardinal: f[11] },
    dv: { cardinal: f[0] },
    ee: { cardinal: f[0] },
    el: { cardinal: f[0] },
    en: { cardinal: f[4], ordinal: f[39] },
    eo: { cardinal: f[0] },
    es: { cardinal: f[0] },
    et: { cardinal: f[4] },
    eu: { cardinal: f[0] },
    fa: { cardinal: f[2] },
    ff: { cardinal: f[12] },
    fi: { cardinal: f[4] },
    fil: { cardinal: f[13], ordinal: f[0] },
    fo: { cardinal: f[0] },
    fr: { cardinal: f[12], ordinal: f[0] },
    fur: { cardinal: f[0] },
    fy: { cardinal: f[4] },
    ga: { cardinal: f[14], ordinal: f[0] },
    gd: { cardinal: f[15] },
    gl: { cardinal: f[4] },
    gsw: { cardinal: f[0] },
    gu: { cardinal: f[2], ordinal: f[40] },
    guw: { cardinal: f[1] },
    gv: { cardinal: f[16] },
    ha: { cardinal: f[0] },
    haw: { cardinal: f[0] },
    he: { cardinal: f[17] },
    hi: { cardinal: f[2], ordinal: f[40] },
    hr: { cardinal: f[7] },
    hsb: { cardinal: f[11] },
    hu: { cardinal: f[0], ordinal: f[41] },
    hy: { cardinal: f[12], ordinal: f[0] },
    io: { cardinal: f[4] },
    is: { cardinal: f[18] },
    it: { cardinal: f[4], ordinal: f[42] },
    iu: { cardinal: f[19] },
    iw: { cardinal: f[17] },
    jgo: { cardinal: f[0] },
    ji: { cardinal: f[4] },
    jmc: { cardinal: f[0] },
    ka: { cardinal: f[0], ordinal: f[43] },
    kab: { cardinal: f[12] },
    kaj: { cardinal: f[0] },
    kcg: { cardinal: f[0] },
    kk: { cardinal: f[0], ordinal: f[44] },
    kkj: { cardinal: f[0] },
    kl: { cardinal: f[0] },
    kn: { cardinal: f[2] },
    ks: { cardinal: f[0] },
    ksb: { cardinal: f[0] },
    ksh: { cardinal: f[20] },
    ku: { cardinal: f[0] },
    kw: { cardinal: f[19] },
    ky: { cardinal: f[0] },
    lag: { cardinal: f[21] },
    lb: { cardinal: f[0] },
    lg: { cardinal: f[0] },
    ln: { cardinal: f[1] },
    lt: { cardinal: f[22] },
    lv: { cardinal: f[23] },
    mas: { cardinal: f[0] },
    mg: { cardinal: f[1] },
    mgo: { cardinal: f[0] },
    mk: { cardinal: f[24], ordinal: f[45] },
    ml: { cardinal: f[0] },
    mn: { cardinal: f[0] },
    mo: { cardinal: f[25], ordinal: f[0] },
    mr: { cardinal: f[2], ordinal: f[46] },
    mt: { cardinal: f[26] },
    nah: { cardinal: f[0] },
    naq: { cardinal: f[19] },
    nb: { cardinal: f[0] },
    nd: { cardinal: f[0] },
    ne: { cardinal: f[0], ordinal: f[47] },
    nl: { cardinal: f[4] },
    nn: { cardinal: f[0] },
    nnh: { cardinal: f[0] },
    no: { cardinal: f[0] },
    nr: { cardinal: f[0] },
    nso: { cardinal: f[1] },
    ny: { cardinal: f[0] },
    nyn: { cardinal: f[0] },
    om: { cardinal: f[0] },
    or: { cardinal: f[0], ordinal: f[48] },
    os: { cardinal: f[0] },
    pa: { cardinal: f[1] },
    pap: { cardinal: f[0] },
    pl: { cardinal: f[27] },
    prg: { cardinal: f[23] },
    ps: { cardinal: f[0] },
    pt: { cardinal: f[28] },
    'pt-PT': { cardinal: f[4] },
    rm: { cardinal: f[0] },
    ro: { cardinal: f[25], ordinal: f[0] },
    rof: { cardinal: f[0] },
    ru: { cardinal: f[29] },
    rwk: { cardinal: f[0] },
    saq: { cardinal: f[0] },
    scn: { cardinal: f[4], ordinal: f[42] },
    sd: { cardinal: f[0] },
    sdh: { cardinal: f[0] },
    se: { cardinal: f[19] },
    seh: { cardinal: f[0] },
    sh: { cardinal: f[7] },
    shi: { cardinal: f[30] },
    si: { cardinal: f[31] },
    sk: { cardinal: f[8] },
    sl: { cardinal: f[32] },
    sma: { cardinal: f[19] },
    smi: { cardinal: f[19] },
    smj: { cardinal: f[19] },
    smn: { cardinal: f[19] },
    sms: { cardinal: f[19] },
    sn: { cardinal: f[0] },
    so: { cardinal: f[0] },
    sq: { cardinal: f[0], ordinal: f[49] },
    sr: { cardinal: f[7] },
    ss: { cardinal: f[0] },
    ssy: { cardinal: f[0] },
    st: { cardinal: f[0] },
    sv: { cardinal: f[4], ordinal: f[50] },
    sw: { cardinal: f[4] },
    syr: { cardinal: f[0] },
    ta: { cardinal: f[0] },
    te: { cardinal: f[0] },
    teo: { cardinal: f[0] },
    ti: { cardinal: f[1] },
    tig: { cardinal: f[0] },
    tk: { cardinal: f[0], ordinal: f[51] },
    tl: { cardinal: f[13], ordinal: f[0] },
    tn: { cardinal: f[0] },
    tr: { cardinal: f[0] },
    ts: { cardinal: f[0] },
    tzm: { cardinal: f[33] },
    ug: { cardinal: f[0] },
    uk: { cardinal: f[29], ordinal: f[52] },
    ur: { cardinal: f[4] },
    uz: { cardinal: f[0] },
    ve: { cardinal: f[0] },
    vo: { cardinal: f[0] },
    vun: { cardinal: f[0] },
    wa: { cardinal: f[1] },
    wae: { cardinal: f[0] },
    xh: { cardinal: f[0] },
    xog: { cardinal: f[0] },
    yi: { cardinal: f[4] },
    zu: { cardinal: f[2] },
    lo: { ordinal: f[0] },
    ms: { ordinal: f[0] },
    vi: { ordinal: f[0] }
  };

  var formatMessageInterpret = createCommonjsModule(function (module, exports) {




  /*::
  import type {
    AST,
    SubMessages
  } from '../format-message-parse'
  type Locale = string
  type Locales = Locale | Locale[]
  type Placeholder = any[] // https://github.com/facebook/flow/issues/4050
  export type Type = (Placeholder, Locales) => (any, ?Object) => any
  export type Types = { [string]: Type }
  */

  exports = module.exports = function interpret (
    ast/*: AST */,
    locale/*:: ?: Locales */,
    types/*:: ?: Types */
  )/*: (args?: Object) => string */ {
    return interpretAST(ast, null, locale || 'en', types || {}, true)
  };

  exports.toParts = function toParts (
    ast/*: AST */,
    locale/*:: ?: Locales */,
    types/*:: ?: Types */
  )/*: (args?: Object) => any[] */ {
    return interpretAST(ast, null, locale || 'en', types || {}, false)
  };

  function interpretAST (
    elements/*: any[] */,
    parent/*: ?Placeholder */,
    locale/*: Locales */,
    types/*: Types */,
    join/*: boolean */
  )/*: Function */ {
    var parts = elements.map(function (element) {
      return interpretElement(element, parent, locale, types, join)
    });

    if (!join) {
      return function format (args) {
        return parts.reduce(function (parts, part) {
          return parts.concat(part(args))
        }, [])
      }
    }

    if (parts.length === 1) return parts[0]
    return function format (args) {
      var message = '';
      for (var e = 0; e < parts.length; ++e) {
        message += parts[e](args);
      }
      return message
    }
  }

  function interpretElement (
    element/*: Placeholder */,
    parent/*: ?Placeholder */,
    locale/*: Locales */,
    types/*: Types */,
    join/*: boolean */
  )/*: Function */ {
    if (typeof element === 'string') {
      var value/*: string */ = element;
      return function format () { return value }
    }

    var id = element[0];
    var type = element[1];

    if (parent && element[0] === '#') {
      id = parent[0];
      var offset = parent[2];
      var formatter = (types.number || defaults.number)([ id, 'number' ], locale);
      return function format (args) {
        return formatter(getArg(id, args) - offset, args)
      }
    }

    // pre-process children
    var children;
    if (type === 'plural' || type === 'selectordinal') {
      children = {};
      Object.keys(element[3]).forEach(function (key) {
        children[key] = interpretAST(element[3][key], element, locale, types, join);
      });
      element = [ element[0], element[1], element[2], children ];
    } else if (element[2] && typeof element[2] === 'object') {
      children = {};
      Object.keys(element[2]).forEach(function (key) {
        children[key] = interpretAST(element[2][key], element, locale, types, join);
      });
      element = [ element[0], element[1], children ];
    }

    var getFrmt = type && (types[type] || defaults[type]);
    if (getFrmt) {
      var frmt = getFrmt(element, locale);
      return function format (args) {
        return frmt(getArg(id, args), args)
      }
    }

    return join
      ? function format (args) { return String(getArg(id, args)) }
      : function format (args) { return getArg(id, args) }
  }

  function getArg (id/*: string */, args/*: ?Object */)/*: any */ {
    if (args && (id in args)) return args[id]
    var parts = id.split('.');
    var a = args;
    for (var i = 0, ii = parts.length; a && i < ii; ++i) {
      a = a[parts[i]];
    }
    return a
  }

  function interpretNumber (element/*: Placeholder */, locales/*: Locales */) {
    var style = element[2];
    var options = formatMessageFormats.number[style] || formatMessageFormats.parseNumberPattern(style) || formatMessageFormats.number.default;
    return new Intl.NumberFormat(locales, options).format
  }

  function interpretDuration (element/*: Placeholder */, locales/*: Locales */) {
    var style = element[2];
    var options = formatMessageFormats.duration[style] || formatMessageFormats.duration.default;
    var fs = new Intl.NumberFormat(locales, options.seconds).format;
    var fm = new Intl.NumberFormat(locales, options.minutes).format;
    var fh = new Intl.NumberFormat(locales, options.hours).format;
    var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':';

    return function (s, args) {
      s = +s;
      if (!isFinite(s)) return fs(s)
      var h = ~~(s / 60 / 60); // ~~ acts much like Math.trunc
      var m = ~~(s / 60 % 60);
      var dur = (h ? (fh(Math.abs(h)) + sep) : '') +
        fm(Math.abs(m)) + sep + fs(Math.abs(s % 60));
      return s < 0 ? fh(-1).replace(fh(1), dur) : dur
    }
  }

  function interpretDateTime (element/*: Placeholder */, locales/*: Locales */) {
    var type = element[1];
    var style = element[2];
    var options = formatMessageFormats[type][style] || formatMessageFormats.parseDatePattern(style) || formatMessageFormats[type].default;
    return new Intl.DateTimeFormat(locales, options).format
  }

  function interpretPlural (element/*: Placeholder */, locales/*: Locales */) {
    var type = element[1];
    var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal';
    var offset = element[2];
    var children = element[3];
    var pluralRules;
    if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {
      pluralRules = new Intl.PluralRules(locales, { type: pluralType });
    } else {
      var locale = lookupClosestLocale(locales, plurals);
      var select = (locale && plurals[locale][pluralType]) || returnOther;
      pluralRules = { select: select };
    }

    return function (value, args) {
      var clause =
        children['=' + +value] ||
        children[pluralRules.select(value - offset)] ||
        children.other;
      return clause(args)
    }
  }

  function returnOther (/*:: n:number */) { return 'other' }

  function interpretSelect (element/*: Placeholder */, locales/*: Locales */) {
    var children = element[2];
    return function (value, args) {
      var clause = children[value] || children.other;
      return clause(args)
    }
  }

  var defaults/*: Types */ = {
    number: interpretNumber,
    ordinal: interpretNumber, // TODO: support rbnf
    spellout: interpretNumber, // TODO: support rbnf
    duration: interpretDuration,
    date: interpretDateTime,
    time: interpretDateTime,
    plural: interpretPlural,
    selectordinal: interpretPlural,
    select: interpretSelect
  };
  exports.types = defaults;
  });
  formatMessageInterpret.toParts;
  formatMessageInterpret.types;

  var formatMessageParse = createCommonjsModule(function (module, exports) {

  /*::
  export type AST = Element[]
  export type Element = string | Placeholder
  export type Placeholder = Plural | Styled | Typed | Simple
  export type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]
  export type Styled = [ string, string, string | SubMessages ]
  export type Typed = [ string, string ]
  export type Simple = [ string ]
  export type SubMessages = { [string]: AST }
  export type Token = [ TokenType, string ]
  export type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'
  type Context = {|
    pattern: string,
    index: number,
    tagsType: ?string,
    tokens: ?Token[]
  |}
  */

  var ARG_OPN = '{';
  var ARG_CLS = '}';
  var ARG_SEP = ',';
  var NUM_ARG = '#';
  var TAG_OPN = '<';
  var TAG_CLS = '>';
  var TAG_END = '</';
  var TAG_SELF_CLS = '/>';
  var ESC = '\'';
  var OFFSET = 'offset:';
  var simpleTypes = [
    'number',
    'date',
    'time',
    'ordinal',
    'duration',
    'spellout'
  ];
  var submTypes = [
    'plural',
    'select',
    'selectordinal'
  ];

  /**
   * parse
   *
   * Turns this:
   *  `You have { numBananas, plural,
   *       =0 {no bananas}
   *      one {a banana}
   *    other {# bananas}
   *  } for sale`
   *
   * into this:
   *  [ "You have ", [ "numBananas", "plural", 0, {
   *       "=0": [ "no bananas" ],
   *      "one": [ "a banana" ],
   *    "other": [ [ '#' ], " bananas" ]
   *  } ], " for sale." ]
   *
   * tokens:
   *  [
   *    [ "text", "You have " ],
   *    [ "syntax", "{" ],
   *    [ "space", " " ],
   *    [ "id", "numBananas" ],
   *    [ "syntax", ", " ],
   *    [ "space", " " ],
   *    [ "type", "plural" ],
   *    [ "syntax", "," ],
   *    [ "space", "\n     " ],
   *    [ "selector", "=0" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "text", "no bananas" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n    " ],
   *    [ "selector", "one" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "text", "a banana" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n  " ],
   *    [ "selector", "other" ],
   *    [ "space", " " ],
   *    [ "syntax", "{" ],
   *    [ "syntax", "#" ],
   *    [ "text", " bananas" ],
   *    [ "syntax", "}" ],
   *    [ "space", "\n" ],
   *    [ "syntax", "}" ],
   *    [ "text", " for sale." ]
   *  ]
   **/
  exports = module.exports = function parse (
    pattern/*: string */,
    options/*:: ?: { tagsType?: string, tokens?: Token[] } */
  )/*: AST */ {
    return parseAST({
      pattern: String(pattern),
      index: 0,
      tagsType: (options && options.tagsType) || null,
      tokens: (options && options.tokens) || null
    }, '')
  };

  function parseAST (current/*: Context */, parentType/*: string */)/*: AST */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var elements/*: AST */ = [];
    var start = current.index;
    var text = parseText(current, parentType);
    if (text) elements.push(text);
    if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ]);
    while (current.index < length) {
      if (pattern[current.index] === ARG_CLS) {
        if (!parentType) throw expected(current)
        break
      }
      if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break
      elements.push(parsePlaceholder(current));
      start = current.index;
      text = parseText(current, parentType);
      if (text) elements.push(text);
      if (text && current.tokens) current.tokens.push([ 'text', pattern.slice(start, current.index) ]);
    }
    return elements
  }

  function parseText (current/*: Context */, parentType/*: string */)/*: string */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var isHashSpecial = (parentType === 'plural' || parentType === 'selectordinal');
    var isAngleSpecial = !!current.tagsType;
    var isArgStyle = (parentType === '{style}');
    var text = '';
    while (current.index < length) {
      var char = pattern[current.index];
      if (
        char === ARG_OPN || char === ARG_CLS ||
        (isHashSpecial && char === NUM_ARG) ||
        (isAngleSpecial && char === TAG_OPN) ||
        (isArgStyle && isWhitespace(char.charCodeAt(0)))
      ) {
        break
      } else if (char === ESC) {
        char = pattern[++current.index];
        if (char === ESC) { // double is always 1 '
          text += char;
          ++current.index;
        } else if (
          // only when necessary
          char === ARG_OPN || char === ARG_CLS ||
          (isHashSpecial && char === NUM_ARG) ||
          (isAngleSpecial && char === TAG_OPN) ||
          isArgStyle
        ) {
          text += char;
          while (++current.index < length) {
            char = pattern[current.index];
            if (char === ESC && pattern[current.index + 1] === ESC) { // double is always 1 '
              text += ESC;
              ++current.index;
            } else if (char === ESC) { // end of quoted
              ++current.index;
              break
            } else {
              text += char;
            }
          }
        } else { // lone ' is just a '
          text += ESC;
          // already incremented
        }
      } else {
        text += char;
        ++current.index;
      }
    }
    return text
  }

  function isWhitespace (code/*: number */)/*: boolean */ {
    return (
      (code >= 0x09 && code <= 0x0D) ||
      code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E ||
      (code >= 0x2000 && code <= 0x200D) ||
      code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F ||
      code === 0x2060 || code === 0x3000 || code === 0xFEFF
    )
  }

  function skipWhitespace (current/*: Context */)/*: void */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var start = current.index;
    while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {
      ++current.index;
    }
    if (start < current.index && current.tokens) {
      current.tokens.push([ 'space', current.pattern.slice(start, current.index) ]);
    }
  }

  function parsePlaceholder (current/*: Context */)/*: Placeholder */ {
    var pattern = current.pattern;
    if (pattern[current.index] === NUM_ARG) {
      if (current.tokens) current.tokens.push([ 'syntax', NUM_ARG ]);
      ++current.index; // move passed #
      return [ NUM_ARG ]
    }

    var tag = parseTag(current);
    if (tag) return tag

    /* istanbul ignore if should be unreachable if parseAST and parseText are right */
    if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN)
    if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ]);
    ++current.index; // move passed {
    skipWhitespace(current);

    var id = parseId(current);
    if (!id) throw expected(current, 'placeholder id')
    if (current.tokens) current.tokens.push([ 'id', id ]);
    skipWhitespace(current);

    var char = pattern[current.index];
    if (char === ARG_CLS) { // end placeholder
      if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ]);
      ++current.index; // move passed }
      return [ id ]
    }

    if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ]);
    ++current.index; // move passed ,
    skipWhitespace(current);

    var type = parseId(current);
    if (!type) throw expected(current, 'placeholder type')
    if (current.tokens) current.tokens.push([ 'type', type ]);
    skipWhitespace(current);
    char = pattern[current.index];
    if (char === ARG_CLS) { // end placeholder
      if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ]);
      if (type === 'plural' || type === 'selectordinal' || type === 'select') {
        throw expected(current, type + ' sub-messages')
      }
      ++current.index; // move passed }
      return [ id, type ]
    }

    if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', ARG_SEP ]);
    ++current.index; // move passed ,
    skipWhitespace(current);

    var arg;
    if (type === 'plural' || type === 'selectordinal') {
      var offset = parsePluralOffset(current);
      skipWhitespace(current);
      arg = [ id, type, offset, parseSubMessages(current, type) ];
    } else if (type === 'select') {
      arg = [ id, type, parseSubMessages(current, type) ];
    } else if (simpleTypes.indexOf(type) >= 0) {
      arg = [ id, type, parseSimpleFormat(current) ];
    } else { // custom placeholder type
      var index = current.index;
      var format/*: string | SubMessages */ = parseSimpleFormat(current);
      skipWhitespace(current);
      if (pattern[current.index] === ARG_OPN) {
        current.index = index; // rewind, since should have been submessages
        format = parseSubMessages(current, type);
      }
      arg = [ id, type, format ];
    }

    skipWhitespace(current);
    if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ]);
    ++current.index; // move passed }
    return arg
  }

  function parseTag (current/*: Context */)/*: ?Placeholder */ {
    var tagsType = current.tagsType;
    if (!tagsType || current.pattern[current.index] !== TAG_OPN) return

    if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {
      throw expected(current, null, 'closing tag without matching opening tag')
    }
    if (current.tokens) current.tokens.push([ 'syntax', TAG_OPN ]);
    ++current.index; // move passed <

    var id = parseId(current, true);
    if (!id) throw expected(current, 'placeholder id')
    if (current.tokens) current.tokens.push([ 'id', id ]);
    skipWhitespace(current);

    if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {
      if (current.tokens) current.tokens.push([ 'syntax', TAG_SELF_CLS ]);
      current.index += TAG_SELF_CLS.length;
      return [ id, tagsType ]
    }
    if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ]);
    ++current.index; // move passed >

    var children = parseAST(current, tagsType);

    var end = current.index;
    if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', TAG_END ]);
    current.index += TAG_END.length;
    var closeId = parseId(current, true);
    if (closeId && current.tokens) current.tokens.push([ 'id', closeId ]);
    if (id !== closeId) {
      current.index = end; // rewind for better error message
      throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS)
    }
    skipWhitespace(current);
    if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)
    if (current.tokens) current.tokens.push([ 'syntax', TAG_CLS ]);
    ++current.index; // move passed >

    return [ id, tagsType, { children: children } ]
  }

  function parseId (current/*: Context */, isTag/*:: ?: boolean */)/*: string */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var id = '';
    while (current.index < length) {
      var char = pattern[current.index];
      if (
        char === ARG_OPN || char === ARG_CLS || char === ARG_SEP ||
        char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) ||
        (isTag && (char === TAG_OPN || char === TAG_CLS || char === '/'))
      ) break
      id += char;
      ++current.index;
    }
    return id
  }

  function parseSimpleFormat (current/*: Context */)/*: string */ {
    var start = current.index;
    var style = parseText(current, '{style}');
    if (!style) throw expected(current, 'placeholder style name')
    if (current.tokens) current.tokens.push([ 'style', current.pattern.slice(start, current.index) ]);
    return style
  }

  function parsePluralOffset (current/*: Context */)/*: number */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var offset = 0;
    if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {
      if (current.tokens) current.tokens.push([ 'offset', 'offset' ], [ 'syntax', ':' ]);
      current.index += OFFSET.length; // move passed offset:
      skipWhitespace(current);
      var start = current.index;
      while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {
        ++current.index;
      }
      if (start === current.index) throw expected(current, 'offset number')
      if (current.tokens) current.tokens.push([ 'number', pattern.slice(start, current.index) ]);
      offset = +pattern.slice(start, current.index);
    }
    return offset
  }

  function isDigit (code/*: number */)/*: boolean */ {
    return (code >= 0x30 && code <= 0x39)
  }

  function parseSubMessages (current/*: Context */, parentType/*: string */)/*: SubMessages */ {
    var pattern = current.pattern;
    var length = pattern.length;
    var options/*: SubMessages */ = {};
    while (current.index < length && pattern[current.index] !== ARG_CLS) {
      var selector = parseId(current);
      if (!selector) throw expected(current, 'sub-message selector')
      if (current.tokens) current.tokens.push([ 'selector', selector ]);
      skipWhitespace(current);
      options[selector] = parseSubMessage(current, parentType);
      skipWhitespace(current);
    }
    if (!options.other && submTypes.indexOf(parentType) >= 0) {
      throw expected(current, null, null, '"other" sub-message must be specified in ' + parentType)
    }
    return options
  }

  function parseSubMessage (current/*: Context */, parentType/*: string */)/*: AST */ {
    if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message')
    if (current.tokens) current.tokens.push([ 'syntax', ARG_OPN ]);
    ++current.index; // move passed {
    var message = parseAST(current, parentType);
    if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message')
    if (current.tokens) current.tokens.push([ 'syntax', ARG_CLS ]);
    ++current.index; // move passed }
    return message
  }

  function expected (current/*: Context */, expected/*:: ?: ?string */, found/*:: ?: ?string */, message/*:: ?: string */) {
    var pattern = current.pattern;
    var lines = pattern.slice(0, current.index).split(/\r?\n/);
    var offset = current.index;
    var line = lines.length;
    var column = lines.slice(-1)[0].length;
    found = found || (
      (current.index >= pattern.length) ? 'end of message pattern'
        : (parseId(current) || pattern[current.index])
    );
    if (!message) message = errorMessage(expected, found);
    message += ' in ' + pattern.replace(/\r?\n/g, '\n');
    return new SyntaxError(message, expected, found, offset, line, column)
  }

  function errorMessage (expected/*: ?string */, found/* string */) {
    if (!expected) return 'Unexpected ' + found + ' found'
    return 'Expected ' + expected + ' but found ' + found
  }

  /**
   * SyntaxError
   *  Holds information about bad syntax found in a message pattern
   **/
  function SyntaxError (message/*: string */, expected/*: ?string */, found/*: ?string */, offset/*: number */, line/*: number */, column/*: number */) {
    Error.call(this, message);
    this.name = 'SyntaxError';
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.offset = offset;
    this.line = line;
    this.column = column;
  }
  SyntaxError.prototype = Object.create(Error.prototype);
  exports.SyntaxError = SyntaxError;
  });
  formatMessageParse.SyntaxError;

  var supportedExp = new RegExp(
    '^(' + Object.keys(plurals).join('|') + ')\\b'
  );

  /*::
  import type { Types } from 'format-message-interpret'
  import type { AST } from 'format-message-parse'
  type Options = {
    types: Types
  }
  type Internals = {
    ast: AST,
    format: (args?: Object) => string,
    locale: string,
    locales?: string | string[],
    toParts?: (args?: Object) => any[],
    options?: Options
  }
  */

  var internals/*: WeakMap<MessageFormat, Internals> */ = new WeakMap();

  /*!
   * Intl.MessageFormat prollyfill
   * Copyright(c) 2015 Andy VanWagoner
   * MIT licensed
   **/
  function MessageFormat (
    pattern/*: string */,
    locales/*:: ?: string | string[] */,
    options/*:: ?: Options */
  ) {
    if (!(this instanceof MessageFormat) || internals.has(this)) {
      throw new TypeError('calling MessageFormat constructor without new is invalid')
    }
    var ast = formatMessageParse(pattern);
    internals.set(this, {
      ast: ast,
      format: formatMessageInterpret(ast, locales, options && options.types),
      locale: MessageFormat.supportedLocalesOf(locales)[0] || 'en',
      locales: locales,
      options: options
    });
  }
  var messageFormat = MessageFormat;

  // $FlowFixMe It thinks `value` needs to be defined for format
  Object.defineProperties(MessageFormat.prototype, {
    format: {
      configurable: true,
      get: function format () {
        var values = internals.get(this);
        if (!values) throw new TypeError('MessageFormat.prototype.format called on value that\'s not an object initialized as a MessageFormat')
        return values.format
      }
    },
    formatToParts: {
      configurable: true,
      writable: true,
      value: function formatToParts (args/*:: ?: Object */) {
        var values = internals.get(this);
        if (!values) throw new TypeError('MessageFormat.prototype.formatToParts called on value that\'s not an object initialized as a MessageFormat')
        var frmt = values.toParts || (values.toParts = formatMessageInterpret.toParts(
          values.ast,
          values.locales,
          values.options && values.options.types
        ));
        return frmt(args)
      }
    },
    resolvedOptions: {
      configurable: true,
      writable: true,
      value: function resolvedOptions () {
        var values = internals.get(this);
        if (!values) throw new TypeError('MessageFormat.prototype.resolvedOptions called on value that\'s not an object initialized as a MessageFormat')
        return {
          locale: values.locale
        }
      }
    }
  });

  /* istanbul ignore else */
  if (typeof Symbol !== 'undefined') {
    Object.defineProperty(MessageFormat.prototype, Symbol.toStringTag, { value: 'Object' });
  }

  Object.defineProperties(MessageFormat, {
    supportedLocalesOf: {
      configurable: true,
      writable: true,
      value: function supportedLocalesOf (requestedLocales/*:: ?: string | string[] */) {
        return [].concat(
          Intl.NumberFormat.supportedLocalesOf(requestedLocales),
          Intl.DateTimeFormat.supportedLocalesOf(requestedLocales),
          Intl.PluralRules ? Intl.PluralRules.supportedLocalesOf(requestedLocales) : [],
          [].concat(requestedLocales || []).filter(function (locale) {
            return supportedExp.test(locale)
          })
        ).filter(function (v, i, a) { return a.indexOf(v) === i })
      }
    }
  });

  /**
   * @param {Object.<string, Object>} obj
   * @returns {boolean}
   */
  function isLocalizeESModule(obj) {
    return !!(obj && obj.default && typeof obj.default === 'object' && Object.keys(obj).length === 1);
  }

  // @ts-expect-error [external]: no types for this package

  /**
   * @typedef {import('../types/LocalizeMixinTypes').NamespaceObject} NamespaceObject
   */

  /** @typedef {import('../types/LocalizeMixinTypes').DatePostProcessor} DatePostProcessor */
  /** @typedef {import('../types/LocalizeMixinTypes').NumberPostProcessor} NumberPostProcessor */

  /**
   * `LocalizeManager` manages your translations (includes loading)
   */
  class LocalizeManager {
    // eslint-disable-line no-unused-vars
    constructor({ autoLoadOnLocaleChange = false, fallbackLocale = '' } = {}) {
      /** @private */
      this.__delegationTarget = document.createDocumentFragment();
      /** @protected */
      this._autoLoadOnLocaleChange = !!autoLoadOnLocaleChange;
      /** @protected */
      this._fallbackLocale = fallbackLocale;

      /**
       * @type {Object.<string, Object.<string, Object>>}
       * @private
       */
      this.__storage = {};

      /**
       * @type {Map.<RegExp|string, function>}
       * @private
       */
      this.__namespacePatternsMap = new Map();

      /**
       * @type {Object.<string, function|null>}
       * @private
       */
      this.__namespaceLoadersCache = {};

      /**
       * @type {Object.<string, Object.<string, Promise.<Object>>>}
       * @private
       */
      this.__namespaceLoaderPromisesCache = {};

      this.formatNumberOptions = {
        returnIfNaN: '',
        /** @type {Map<string,DatePostProcessor>} */
        postProcessors: new Map(),
      };

      this.formatDateOptions = {
        /** @type {Map<string,DatePostProcessor>} */
        postProcessors: new Map(),
      };

      /**
       * Via html[data-localize-lang], developers are allowed to set the initial locale, without
       * having to worry about whether locale is initialized before 3rd parties like Google Translate.
       * When this value differs from html[lang], we assume the 3rd party took
       * control over the page language and we set this._langAttrSetByTranslationTool to html[lang]
       */
      const initialLocale = document.documentElement.getAttribute('data-localize-lang');

      /** @protected */
      this._supportExternalTranslationTools = Boolean(initialLocale);

      if (this._supportExternalTranslationTools) {
        this.locale = initialLocale || 'en-GB';
        this._setupTranslationToolSupport();
      }

      if (!document.documentElement.lang) {
        document.documentElement.lang = this.locale || 'en-GB';
      }

      /** @protected */
      this._setupHtmlLangAttributeObserver();
    }

    /** @protected */
    _setupTranslationToolSupport() {
      /**
       * This value allows for support for Google Translate (or other 3rd parties taking control
       * of the html[lang] attribute).
       *
       * Have the following scenario in mind:
       * 1. locale is initialized by developer via html[data-localize-lang="en-US"] and
       * html[lang="en-US"]. When localize is loaded (note that this also can be after step 2 below),
       * it will sync its initial state from html[data-localize-lang]
       * 2. Google Translate kicks in for the French language. It will set html[lang="fr"].
       * This new language is not one known by us, so we most likely don't have translations for
       * this file. Therefore, we do NOT sync this value to LocalizeManager. The manager should
       * still ask for known resources (in this case for locale 'en-US')
       * 3. locale is changed (think of a language dropdown)
       * It's a bit of a weird case, because we would not expect an end user to do this. If he/she
       * does, make sure that we do not go against Google Translate, so we maintain accessibility
       * (by not altering html[lang]). We detect this by reading _langAttrSetByTranslationTool:
       * when its value is null, we consider Google translate 'not active'.
       *
       * When Google Translate is turned off by the user (html[lang=auto]),
       * `localize.locale` will be synced to html[lang] again
       *
       * Keep in mind that all of the above also works with other tools than Google Translate,
       * but this is the most widely used tool and therefore used as an example.
       */
      this._langAttrSetByTranslationTool = document.documentElement.lang || null;
    }

    teardown() {
      this._teardownHtmlLangAttributeObserver();
    }

    /**
     * @returns {string}
     */
    get locale() {
      if (this._supportExternalTranslationTools) {
        return this.__locale || '';
      }
      return document.documentElement.lang;
    }

    /**
     * @param {string} value
     */
    set locale(value) {
      /** @type {string} */
      let oldLocale;
      if (this._supportExternalTranslationTools) {
        oldLocale = /** @type {string} */ (this.__locale);
        this.__locale = value;
        if (this._langAttrSetByTranslationTool === null) {
          this._setHtmlLangAttribute(value);
        }
      } else {
        oldLocale = document.documentElement.lang;
        this._setHtmlLangAttribute(value);
      }

      if (!value.includes('-')) {
        this.__handleLanguageOnly(value);
      }

      this._onLocaleChanged(value, oldLocale);
    }

    /**
     * @param {string} locale
     * @protected
     */
    _setHtmlLangAttribute(locale) {
      this._teardownHtmlLangAttributeObserver();
      document.documentElement.lang = locale;
      this._setupHtmlLangAttributeObserver();
    }

    /**
     * @param {string} value
     * @throws {Error} Language only locales are not allowed(Use 'en-GB' instead of 'en')
     * @private
     */
    // eslint-disable-next-line class-methods-use-this
    __handleLanguageOnly(value) {
      throw new Error(`
      Locale was set to ${value}.
      Language only locales are not allowed, please use the full language locale e.g. 'en-GB' instead of 'en'.
      See https://github.com/ing-bank/lion/issues/187 for more information.
    `);
    }

    /**
     * @returns {Promise.<Object>}
     */
    get loadingComplete() {
      return Promise.all(Object.values(this.__namespaceLoaderPromisesCache[this.locale]));
    }

    reset() {
      this.__storage = {};
      this.__namespacePatternsMap = new Map();
      this.__namespaceLoadersCache = {};
      this.__namespaceLoaderPromisesCache = {};
    }

    /**
     * @param {string} locale
     * @param {string} namespace
     * @param {object} data
     * @throws {Error} Namespace can be added only once, for a given locale
     */
    addData(locale, namespace, data) {
      if (this._isNamespaceInCache(locale, namespace)) {
        throw new Error(
          `Namespace "${namespace}" has been already added for the locale "${locale}".`,
        );
      }

      this.__storage[locale] = this.__storage[locale] || {};
      this.__storage[locale][namespace] = data;
    }

    /**
     * @param {RegExp|string} pattern
     * @param {function} loader
     */
    setupNamespaceLoader(pattern, loader) {
      this.__namespacePatternsMap.set(pattern, loader);
    }

    /**
     * @param {NamespaceObject[]} namespaces
     * @param {Object} [options]
     * @param {string} [options.locale]
     * @returns {Promise.<Object>}
     */
    loadNamespaces(namespaces, { locale } = {}) {
      return Promise.all(
        namespaces.map(
          /** @param {NamespaceObject} namespace */
          namespace => this.loadNamespace(namespace, { locale }),
        ),
      );
    }

    /**
     * @param {NamespaceObject} namespaceObj
     * @param {Object} [options]
     * @param {string} [options.locale]
     * @returns {Promise.<Object|void>}
     */
    loadNamespace(namespaceObj, { locale = this.locale } = { locale: this.locale }) {
      const isDynamicImport = typeof namespaceObj === 'object';

      const namespace = /** @type {string} */ (isDynamicImport
        ? Object.keys(namespaceObj)[0]
        : namespaceObj);

      if (this._isNamespaceInCache(locale, namespace)) {
        return Promise.resolve();
      }

      const existingLoaderPromise = this._getCachedNamespaceLoaderPromise(locale, namespace);
      if (existingLoaderPromise) {
        return existingLoaderPromise;
      }

      return this._loadNamespaceData(locale, namespaceObj, isDynamicImport, namespace);
    }

    /**
     * @param {string | string[]} keys
     * @param {Object.<string,?>} [vars]
     * @param {Object} [opts]
     * @param {string} [opts.locale]
     * @returns {string}
     */
    msg(keys, vars, opts = {}) {
      const locale = opts.locale ? opts.locale : this.locale;
      const message = this._getMessageForKeys(keys, locale);
      if (!message) {
        return '';
      }
      const formatter = new messageFormat(message, locale);
      return formatter.format(vars);
    }

    /** @protected */
    _setupHtmlLangAttributeObserver() {
      if (!this._htmlLangAttributeObserver) {
        this._htmlLangAttributeObserver = new MutationObserver(mutations => {
          mutations.forEach(mutation => {
            if (this._supportExternalTranslationTools) {
              if (document.documentElement.lang === 'auto') {
                // Google Translate is switched off
                this._langAttrSetByTranslationTool = null;
                this._setHtmlLangAttribute(this.locale);
              } else {
                this._langAttrSetByTranslationTool = document.documentElement.lang;
              }
            } else {
              this._onLocaleChanged(document.documentElement.lang, mutation.oldValue || '');
            }
          });
        });
      }
      this._htmlLangAttributeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['lang'],
        attributeOldValue: true,
      });
    }

    /** @protected */
    _teardownHtmlLangAttributeObserver() {
      if (this._htmlLangAttributeObserver) {
        this._htmlLangAttributeObserver.disconnect();
      }
    }

    /**
     * @param {string} locale
     * @param {string} namespace
     * @protected
     */
    _isNamespaceInCache(locale, namespace) {
      return !!(this.__storage[locale] && this.__storage[locale][namespace]);
    }

    /**
     * @param {string} locale
     * @param {string} namespace
     * @protected
     */
    _getCachedNamespaceLoaderPromise(locale, namespace) {
      if (this.__namespaceLoaderPromisesCache[locale]) {
        return this.__namespaceLoaderPromisesCache[locale][namespace];
      }
      return null;
    }

    /**
     * @param {string} locale
     * @param {NamespaceObject} namespaceObj
     * @param {boolean} isDynamicImport
     * @param {string} namespace
     * @returns {Promise.<Object|void>}
     * @protected
     */
    _loadNamespaceData(locale, namespaceObj, isDynamicImport, namespace) {
      const loader = this._getNamespaceLoader(namespaceObj, isDynamicImport, namespace);
      const loaderPromise = this._getNamespaceLoaderPromise(loader, locale, namespace);
      this._cacheNamespaceLoaderPromise(locale, namespace, loaderPromise);
      return loaderPromise.then(
        /**
         * @param {Object} obj
         * @param {Object} obj.default
         */
        obj => {
          const data = isLocalizeESModule(obj) ? obj.default : obj;
          this.addData(locale, namespace, data);
        },
      );
    }

    /**
     * @param {NamespaceObject} namespaceObj
     * @param {boolean} isDynamicImport
     * @param {string} namespace
     * @throws {Error} Namespace shall setup properly. Check loader!
     * @protected
     */
    _getNamespaceLoader(namespaceObj, isDynamicImport, namespace) {
      let loader = this.__namespaceLoadersCache[namespace];
      if (!loader) {
        if (isDynamicImport) {
          const _namespaceObj = /** @type {Object.<string,function>} */ (namespaceObj);
          loader = _namespaceObj[namespace];
          this.__namespaceLoadersCache[namespace] = loader;
        } else {
          loader = this._lookupNamespaceLoader(namespace);
          this.__namespaceLoadersCache[namespace] = loader;
        }
      }

      if (!loader) {
        throw new Error(`Namespace "${namespace}" was not properly setup.`);
      }

      this.__namespaceLoadersCache[namespace] = loader;

      return loader;
    }

    /**
     * @param {function} loader
     * @param {string} locale
     * @param {string} namespace
     * @param {string} [fallbackLocale]
     * @returns {Promise.<any>}
     * @throws {Error} Data for namespace and (locale or fallback locale) could not be loaded.
     * @protected
     */
    _getNamespaceLoaderPromise(loader, locale, namespace, fallbackLocale = this._fallbackLocale) {
      return loader(locale, namespace).catch(() => {
        const lang = this._getLangFromLocale(locale);
        return loader(lang, namespace).catch(() => {
          if (fallbackLocale) {
            return this._getNamespaceLoaderPromise(loader, fallbackLocale, namespace, '').catch(
              () => {
                const fallbackLang = this._getLangFromLocale(fallbackLocale);
                throw new Error(
                  `Data for namespace "${namespace}" and current locale "${locale}" or fallback locale "${fallbackLocale}" could not be loaded. ` +
                    `Make sure you have data either for locale "${locale}" (and/or generic language "${lang}") or for fallback "${fallbackLocale}" (and/or "${fallbackLang}").`,
                );
              },
            );
          }
          throw new Error(
            `Data for namespace "${namespace}" and locale "${locale}" could not be loaded. ` +
              `Make sure you have data for locale "${locale}" (and/or generic language "${lang}").`,
          );
        });
      });
    }

    /**
     * @param {string} locale
     * @param {string} namespace
     * @param {Promise.<Object>} promise
     * @protected
     */
    _cacheNamespaceLoaderPromise(locale, namespace, promise) {
      if (!this.__namespaceLoaderPromisesCache[locale]) {
        this.__namespaceLoaderPromisesCache[locale] = {};
      }
      this.__namespaceLoaderPromisesCache[locale][namespace] = promise;
    }

    /**
     * @param {string} namespace
     * @returns {function|null}
     * @protected
     */
    _lookupNamespaceLoader(namespace) {
      /* eslint-disable no-restricted-syntax */
      for (const [key, value] of this.__namespacePatternsMap) {
        const isMatchingString = typeof key === 'string' && key === namespace;
        const isMatchingRegexp =
          typeof key === 'object' && key.constructor.name === 'RegExp' && key.test(namespace);
        if (isMatchingString || isMatchingRegexp) {
          return value;
        }
      }
      return null;
      /* eslint-enable no-restricted-syntax */
    }

    /**
     * @param {string} locale
     * @returns {string}
     * @protected
     */
    // eslint-disable-next-line class-methods-use-this
    _getLangFromLocale(locale) {
      return locale.substring(0, 2);
    }

    /**
     * @param {string} type
     * @param {EventListener} listener
     * @param {...Object} options
     */
    addEventListener(type, listener, ...options) {
      this.__delegationTarget.addEventListener(type, listener, ...options);
    }

    /**
     * @param {string} type
     * @param {EventListener} listener
     * @param {...Object} options
     */
    removeEventListener(type, listener, ...options) {
      this.__delegationTarget.removeEventListener(type, listener, ...options);
    }

    /**
     *  @param {CustomEvent} event
     */
    dispatchEvent(event) {
      this.__delegationTarget.dispatchEvent(event);
    }

    /**
     * @param {string} newLocale
     * @param {string} oldLocale
     * @returns {undefined}
     * @protected
     */
    _onLocaleChanged(newLocale, oldLocale) {
      if (newLocale === oldLocale) {
        return;
      }
      if (this._autoLoadOnLocaleChange) {
        this._loadAllMissing(newLocale, oldLocale);
      }
      this.dispatchEvent(new CustomEvent('localeChanged', { detail: { newLocale, oldLocale } }));
    }

    /**
     * @param {string} newLocale
     * @param {string} oldLocale
     * @returns {Promise.<Object>}
     * @protected
     */
    _loadAllMissing(newLocale, oldLocale) {
      const oldLocaleNamespaces = this.__storage[oldLocale] || {};
      const newLocaleNamespaces = this.__storage[newLocale] || {};
      /** @type {Promise<Object|void>[]} */
      const promises = [];
      Object.keys(oldLocaleNamespaces).forEach(namespace => {
        const newNamespaceData = newLocaleNamespaces[namespace];
        if (!newNamespaceData) {
          promises.push(
            this.loadNamespace(namespace, {
              locale: newLocale,
            }),
          );
        }
      });
      return Promise.all(promises);
    }

    /**
     * @param {string | string[]} keys
     * @param {string} locale
     * @returns {string | undefined}
     * @protected
     */
    _getMessageForKeys(keys, locale) {
      if (typeof keys === 'string') {
        return this._getMessageForKey(keys, locale);
      }
      const reversedKeys = Array.from(keys).reverse(); // Array.from prevents mutation of argument
      let key;
      let message;
      while (reversedKeys.length) {
        key = reversedKeys.pop();
        message = this._getMessageForKey(key, locale);
        if (message) {
          return message;
        }
      }
      return undefined;
    }

    /**
     * @param {string | undefined} key
     * @param {string} locale
     * @returns {string}
     * @throws {Error} `key`is missing namespace. The format for `key` is "namespace:name"
     * @protected
     *
     */
    _getMessageForKey(key, locale) {
      if (!key || key.indexOf(':') === -1) {
        throw new Error(
          `Namespace is missing in the key "${key}". The format for keys is "namespace:name".`,
        );
      }
      const [ns, namesString] = key.split(':');
      const namespaces = this.__storage[locale];
      const messages = namespaces ? namespaces[ns] : {};
      const names = namesString.split('.');
      const result = names.reduce(
        /**
         * @param {Object.<string, any> | string} message
         * @param {string} name
         * @returns {string}
         */
        (message, name) => (typeof message === 'object' ? message[name] : message),
        messages,
      );

      return String(result || '');
    }

    /**
     * @param {{locale:string, postProcessor:DatePostProcessor}} options
     */
    setDatePostProcessorForLocale({ locale, postProcessor }) {
      this.formatDateOptions.postProcessors.set(locale, postProcessor);
    }

    /**
     * @param {{locale:string, postProcessor:NumberPostProcessor}} options
     */
    setNumberPostProcessorForLocale({ locale, postProcessor }) {
      this.formatNumberOptions.postProcessors.set(locale, postProcessor);
    }
  }

  /** @type {LocalizeManager} */
  // eslint-disable-next-line import/no-mutable-exports
  let localize =
    singletonManager.get('@lion/localize::localize::0.10.x') ||
    new LocalizeManager({
      autoLoadOnLocaleChange: true,
      fallbackLocale: 'en-GB',
    });

  // TODO: still needed? It can be solved with while loop as well

  /**
   * Use the `.add` method to add async functions to the queue
   * Await the `.complete` if you want to ensure the queue is empty at any point
   * `complete` resolves whenever no more tasks are running.
   * Important note: Currently runs tasks 1 by 1, there is no concurrency option at the moment
   */
  class AsyncQueue {
    constructor() {
      this.__running = false;
      /** @type {function[]} */
      this.__queue = [];
    }

    /**
     *
     * @param {function} task
     */
    add(task) {
      this.__queue.push(task);
      if (!this.__running) {
        // We have a new queue, because before there was nothing in the queue
        this.complete = new Promise(resolve => {
          /** @type {function} */
          this.__callComplete = resolve;
        });
        this.__run();
      }
    }

    /** @private */
    async __run() {
      this.__running = true;
      await this.__queue[0]();
      this.__queue.shift();
      if (this.__queue.length > 0) {
        this.__run();
      } else {
        this.__running = false;
        if (this.__callComplete) {
          this.__callComplete();
        }
      }
    }
  }

  /**
   * Return PascalCased version of the camelCased string
   *
   * @param {string} str
   * @return {string}
   */
  function pascalCase(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // TODO: will be moved to @Lion/core later?

  /**
   * @typedef {import('../../types/utils/SyncUpdatableMixinTypes').SyncUpdatableMixin} SyncUpdatableMixin
   * @typedef {import('../../types/utils/SyncUpdatableMixinTypes').SyncUpdatableNamespace} SyncUpdatableNamespace
   */

  /**
   * @desc Why this mixin?
   * - it adheres to the "Member Order Independence" web components standard:
   * https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence
   * - sync observers can be dependent on the outcome of the render function (or, more generically
   * speaking, the light and shadow dom). This aligns with the 'updated' callback that is supported
   * out of the box by LitElement, which runs after connectedCallback as well.
   * - makes the propertyAccessor.`hasChanged` compatible in synchronous updates:
   * `updateSync` will only be called when new value differs from old value.
   * See: https://lit-element.polymer-project.org/guide/lifecycle#haschanged
   * - it is a stable abstraction on top of a protected/non official lifecycle LitElement api.
   * Whenever the implementation of `requestUpdateInternal` changes (this happened in the past for
   * `requestUpdate`) we only have to change our abstraction instead of all our components
   * @type {SyncUpdatableMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   */
  const SyncUpdatableMixinImplementation = superclass =>
    class extends superclass {
      constructor() {
        super();
        // Namespace for this mixin that guarantees naming clashes will not occur...
        /**
         * @type {SyncUpdatableNamespace}
         */
        this.__SyncUpdatableNamespace = {};
      }

      /**
       * Empty pending queue in order to guarantee order independence
       *
       * @param {import('lit-element').PropertyValues } changedProperties
       */
      firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this.__syncUpdatableInitialize();
      }

      connectedCallback() {
        super.connectedCallback();
        this.__SyncUpdatableNamespace.connected = true;
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.__SyncUpdatableNamespace.connected = false;
      }

      /**
       * Makes the propertyAccessor.`hasChanged` compatible in synchronous updates
       * @param {string} name
       * @param {*} newValue
       * @param {*} oldValue
       * @private
       */
      static __syncUpdatableHasChanged(name, newValue, oldValue) {
        // @ts-expect-error [external]: accessing private lit property
        const properties = this._classProperties;
        if (properties.get(name) && properties.get(name).hasChanged) {
          return properties.get(name).hasChanged(newValue, oldValue);
        }
        return newValue !== oldValue;
      }

      /** @private */
      __syncUpdatableInitialize() {
        const ns = this.__SyncUpdatableNamespace;
        const ctor = /** @type {typeof SyncUpdatableMixin & typeof import('../../types/utils/SyncUpdatableMixinTypes').SyncUpdatableHost} */ (this
          .constructor);

        ns.initialized = true;
        // Empty queue...
        if (ns.queue) {
          Array.from(ns.queue).forEach(name => {
            // @ts-ignore [allow-private] in test
            if (ctor.__syncUpdatableHasChanged(name, this[name], undefined)) {
              this.updateSync(name, undefined);
            }
          });
        }
      }

      /**
       * @param {string} name
       * @param {*} oldValue
       */
      requestUpdateInternal(name, oldValue) {
        super.requestUpdateInternal(name, oldValue);

        this.__SyncUpdatableNamespace = this.__SyncUpdatableNamespace || {};
        const ns = this.__SyncUpdatableNamespace;

        const ctor = /** @type {typeof SyncUpdatableMixin & typeof import('../../types/utils/SyncUpdatableMixinTypes').SyncUpdatableHost} */ (this
          .constructor);
        // Before connectedCallback: queue
        if (!ns.initialized) {
          ns.queue = ns.queue || new Set();
          // Makes sure that we only initialize one time, with most up to date value
          ns.queue.add(name);
        } // After connectedCallback: guarded proxy to updateSync
        // @ts-ignore [allow-private] in test
        else if (ctor.__syncUpdatableHasChanged(name, this[name], oldValue)) {
          this.updateSync(name, oldValue);
        }
      }

      /**
       * @desc A public abstraction that has the exact same api as `requestUpdateInternal`.
       * All code previously present in requestUpdateInternal can be placed in this method.
       * @param {string} name
       * @param {*} oldValue
       */
      updateSync(name, oldValue) {} // eslint-disable-line class-methods-use-this, no-unused-vars
    };

  const SyncUpdatableMixin = dedupeMixin(SyncUpdatableMixinImplementation);

  /**
   * @typedef {import('../validate/Validator').Validator} Validator
   * @typedef {import('@lion/core').TemplateResult} TemplateResult
   * @typedef {Object} messageMap
   * @property {string | Node} message
   * @property {string} type
   * @property {Validator} [validator]
   */

  /**
   * @desc Takes care of accessible rendering of error messages
   * Should be used in conjunction with FormControl having ValidateMixin applied
   */
  class LionValidationFeedback extends LitElement {
    static get properties() {
      return {
        feedbackData: { attribute: false },
      };
    }

    /**
     * @overridable
     * @param {Object} opts
     * @param {string | Node | TemplateResult } opts.message message or feedback node or TemplateResult
     * @param {string} [opts.type]
     * @param {Validator} [opts.validator]
     * @protected
     */
    // eslint-disable-next-line class-methods-use-this
    _messageTemplate({ message }) {
      return message;
    }

    /**
     * @param {import('@lion/core').PropertyValues } changedProperties
     */
    updated(changedProperties) {
      super.updated(changedProperties);
      if (this.feedbackData && this.feedbackData[0]) {
        this.setAttribute('type', this.feedbackData[0].type);
        this.currentType = this.feedbackData[0].type;
        window.clearTimeout(this.removeMessage);
        if (this.currentType === 'success') {
          this.removeMessage = window.setTimeout(() => {
            this.removeAttribute('type');
            /** @type {messageMap[]} */
            this.feedbackData = [];
          }, 3000);
        }
      } else if (this.currentType !== 'success') {
        this.removeAttribute('type');
      }
    }

    render() {
      return html`
      ${this.feedbackData &&
      this.feedbackData.map(
        ({ message, type, validator }) => html`
          ${this._messageTemplate({ message, type, validator })}
        `,
      )}
    `;
    }
  }

  /**
   * @typedef {object} MessageData
   * @property {*} [MessageData.modelValue]
   * @property {string} [MessageData.fieldName]
   * @property {HTMLElement} [MessageData.formControl]
   * @property {string} [MessageData.type]
   * @property {Object.<string,?>} [MessageData.config]
   * @property {string} [MessageData.name]
   */

  class Validator {
    /**
     *
     * @param {?} [param]
     * @param {Object.<string,?>} [config]
     */
    constructor(param, config) {
      this.__fakeExtendsEventTarget();

      /** @type {?} */
      this.__param = param;

      /** @type {Object.<string,?>} */
      this.__config = config || {};
      this.type = (config && config.type) || 'error'; // Default type supported by ValidateMixin
    }

    static get validatorName() {
      return '';
    }

    static get async() {
      return false;
    }

    /**
     * @desc The function that returns a Boolean
     * @param {?} [modelValue]
     * @param {?} [param]
     * @param {{}} [config]
     * @returns {Boolean|Promise<Boolean>}
     */
    // eslint-disable-next-line no-unused-vars, class-methods-use-this
    execute(modelValue, param, config) {
      const ctor = /** @type {typeof Validator} */ (this.constructor);
      if (!ctor.validatorName) {
        throw new Error(
          'A validator needs to have a name! Please set it via "static get validatorName() { return \'IsCat\'; }"',
        );
      }
      return true;
    }

    set param(p) {
      this.__param = p;
      if (this.dispatchEvent) {
        this.dispatchEvent(new Event('param-changed'));
      }
    }

    get param() {
      return this.__param;
    }

    set config(c) {
      this.__config = c;
      if (this.dispatchEvent) {
        this.dispatchEvent(new Event('config-changed'));
      }
    }

    get config() {
      return this.__config;
    }

    /**
     * @overridable
     * @param {MessageData} [data]
     * @returns {Promise<string|Node>}
     * @protected
     */
    async _getMessage(data) {
      const ctor = /** @type {typeof Validator} */ (this.constructor);
      const composedData = {
        name: ctor.validatorName,
        type: this.type,
        params: this.param,
        config: this.config,
        ...data,
      };
      if (this.config.getMessage) {
        if (typeof this.config.getMessage === 'function') {
          return this.config.getMessage(composedData);
        }
        throw new Error(
          `You must provide a value for getMessage of type 'function', you provided a value of type: ${typeof this
          .config.getMessage}`,
        );
      }
      return ctor.getMessage(composedData);
    }

    /**
     * @overridable
     * @param {MessageData} [data]
     * @returns {Promise<string|Node>}
     */
    // eslint-disable-next-line no-unused-vars
    static async getMessage(data) {
      return `Please configure an error message for "${this.name}" by overriding "static async getMessage()"`;
    }

    /**
     * @param {HTMLElement} formControl
     */
    onFormControlConnect(formControl) {} // eslint-disable-line

    /**
     * @param {HTMLElement} formControl
     */
    onFormControlDisconnect(formControl) {} // eslint-disable-line

    /**
     * @desc Used on async Validators, makes it able to do perf optimizations when there are
     * pending "execute" calls with outdated values.
     * ValidateMixin calls Validator.abortExecution() an async Validator can act accordingly,
     * depending on its implementation of the "execute" function.
     * - For instance, when fetch was called:
     * https://stackoverflow.com/questions/31061838/how-do-i-cancel-an-http-fetch-request
     * - Or, when a webworker was started, its process could be aborted and then restarted.
     */
    abortExecution() {} // eslint-disable-line

    /**
     * @private
     */
    __fakeExtendsEventTarget() {
      const delegate = document.createDocumentFragment();

      /**
       *
       * @param {string} type
       * @param {EventListener} listener
       * @param {Object} [opts]
       */
      const delegatedAddEventListener = (type, listener, opts) =>
        delegate.addEventListener(type, listener, opts);

      /**
       * @param {string} type
       * @param {EventListener} listener
       * @param {Object} [opts]
       */
      const delegatedRemoveEventListener = (type, listener, opts) =>
        delegate.removeEventListener(type, listener, opts);

      /**
       * @param {Event|CustomEvent} event
       */
      const delegatedDispatchEvent = event => delegate.dispatchEvent(event);

      this.addEventListener = delegatedAddEventListener;

      this.removeEventListener = delegatedRemoveEventListener;

      this.dispatchEvent = delegatedDispatchEvent;
    }
  }

  // For simplicity, a default validator only handles one state:
  // it can either be true or false an it will only have one message.
  // In more advanced cases (think of the feedback mechanism for the maximum number of
  // characters in Twitter), more states are needed. The alternative of
  // having multiple distinct validators would be cumbersome to create and maintain,
  // also because the validations would tie too much into each others logic.

  /**
   * @desc Instead of evaluating the result of a regular validator, a ResultValidator looks
   * at the total result of regular Validators. Instead of an execute function, it uses a
   * 'executeOnResults' Validator.
   * ResultValidators cannot be async, and should not contain an execute method.
   */
  class ResultValidator extends Validator {
    /**
     * @param {Object} context
     * @param {Validator[]} context.regularValidationResult
     * @param {Validator[]} context.prevValidationResult
     * @param {Validator[]} context.prevShownValidationResult
     * @param {Validator[]} [context.validators]
     * @returns {boolean}
     */
    /* eslint-disable no-unused-vars */
    // eslint-disable-next-line class-methods-use-this
    executeOnResults({
      regularValidationResult,
      prevValidationResult,
      prevShownValidationResult,
      validators,
    }) {
      /* eslint-enable no-unused-vars */
      return true;
    }
  }

  /**
   * @typedef {import('../../../types/FormControlMixinTypes.js').FormControlHost} FormControlHost
   */

  class Required extends Validator {
    static get validatorName() {
      return 'Required';
    }

    /**
     * In order to prevent accessibility violations, the aria-required attribute will
     * be combined with compatible aria roles: https://www.w3.org/TR/wai-aria/#aria-required
     */
    static get _compatibleRoles() {
      return [
        'combobox',
        'gridcell',
        'input',
        'listbox',
        'radiogroup',
        'select',
        'spinbutton',
        'textarea',
        'textbox',
        'tree',
      ];
    }

    /**
     * In order to prevent accessibility violations, the aria-required attribute will
     * be combined with compatible platform input elements
     */
    static get _compatibleTags() {
      return ['input', 'select', 'textarea'];
    }

    /**
     * We don't have an execute function, since the Required validator is 'special'.
     * The outcome depends on the modelValue of the FormControl and
     * FormControl.__isEmpty / FormControl._isEmpty.
     */

    /**
     * @param {FormControlHost & HTMLElement} formControl
     */
    // @ts-ignore [allow-protected] we are allowed to know FormControl protcected props in form-core
    // eslint-disable-next-line class-methods-use-this
    onFormControlConnect({ _inputNode: inputNode }) {
      if (inputNode) {
        const role = inputNode.getAttribute('role') || '';
        const elementTagName = inputNode.tagName.toLowerCase();
        const ctor = /** @type {typeof Required} */ (this.constructor);
        if (ctor._compatibleRoles.includes(role) || ctor._compatibleTags.includes(elementTagName)) {
          inputNode.setAttribute('aria-required', 'true');
        }
      }
    }

    /**
     * @param {FormControlHost & HTMLElement} formControl
     */
    // @ts-ignore [allow-protected] we are allowed to know FormControl protcected props in form-core
    // eslint-disable-next-line class-methods-use-this
    onFormControlDisconnect({ _inputNode: inputNode }) {
      if (inputNode) {
        inputNode.removeAttribute('aria-required');
      }
    }
  }

  /* eslint-disable class-methods-use-this, camelcase, no-param-reassign, max-classes-per-file */

  /**
   * @typedef {import('../../types/validate/ValidateMixinTypes').ValidateMixin} ValidateMixin
   */

  /**
   * @param {any[]} array1
   * @param {any[]} array2
   */
  function arrayDiff(array1 = [], array2 = []) {
    return array1.filter(x => !array2.includes(x)).concat(array2.filter(x => !array1.includes(x)));
  }

  /**
   * @desc Handles all validation, based on modelValue changes. It has no knowledge about dom and
   * UI. All error visibility, dom interaction and accessibility are handled in FeedbackMixin.
   *
   * @type {ValidateMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   */
  const ValidateMixinImplementation = superclass =>
    class extends FormControlMixin(
      SyncUpdatableMixin(DisabledMixin(SlotMixin(ScopedElementsMixin(superclass)))),
    ) {
      static get scopedElements() {
        const scopedElementsCtor = /** @type {typeof import('@open-wc/scoped-elements/src/types').ScopedElementsHost} */ (super
          .constructor);
        return {
          ...scopedElementsCtor.scopedElements,
          'lion-validation-feedback': LionValidationFeedback,
        };
      }

      /** @type {any} */
      static get properties() {
        return {
          validators: { attribute: false },

          hasFeedbackFor: { attribute: false },

          shouldShowFeedbackFor: { attribute: false },

          showsFeedbackFor: {
            type: Array,
            attribute: 'shows-feedback-for',
            reflect: true,
            converter: {
              fromAttribute: /** @param {string} value */ value => value.split(','),
              toAttribute: /** @param {[]} value */ value => value.join(','),
            },
          },

          validationStates: { attribute: false },

          /**
           * @desc flag that indicates whether async validation is pending
           */
          isPending: {
            type: Boolean,
            attribute: 'is-pending',
            reflect: true,
          },

          /**
           * @desc specialized fields (think of input-date and input-email) can have preconfigured
           * validators.
           */
          defaultValidators: { attribute: false },

          /**
           * Subclassers can enable this to show multiple feedback messages at the same time
           * By default, just like the platform, only one message (with highest prio) is visible.
           */
          _visibleMessagesAmount: { attribute: false },

          __childModelValueChanged: { attribute: false },
        };
      }

      /**
       * @overridable
       */
      static get validationTypes() {
        return ['error'];
      }

      /**
       * @overridable
       * Adds "._feedbackNode" as described below
       */
      get slots() {
        /**
         * FIXME: Ugly workaround https://github.com/microsoft/TypeScript/issues/40110
         * @callback getScopedTagName
         * @param {string} tagName
         * @returns {string}
         *
         * @typedef {Object} ScopedElementsObj
         * @property {getScopedTagName} getScopedTagName
         */
        const ctor = /** @type {typeof ValidateMixin & ScopedElementsObj} */ (this.constructor);
        return {
          ...super.slots,
          feedback: () => {
            const feedbackEl = document.createElement(
              ctor.getScopedTagName('lion-validation-feedback'),
            );
            feedbackEl.setAttribute('data-tag-name', 'lion-validation-feedback');
            return feedbackEl;
          },
        };
      }

      get _allValidators() {
        return [...this.validators, ...this.defaultValidators];
      }

      constructor() {
        super();

        /** @type {string[]} */
        this.hasFeedbackFor = [];

        /** @type {string[]} */
        this.shouldShowFeedbackFor = [];

        /** @type {string[]} */
        this.showsFeedbackFor = [];

        /** @type {Object.<string, Object.<string, boolean>>} */
        this.validationStates = {};

        /** @protected */
        this._visibleMessagesAmount = 1;

        this.isPending = false;

        /** @type {Validator[]} */
        this.validators = [];
        /** @type {Validator[]} */
        this.defaultValidators = [];

        /**
         * @type {Validator[]}
         * @private
         */
        this.__syncValidationResult = [];

        /**
         * @type {Validator[]}
         * @private
         */
        this.__asyncValidationResult = [];

        /**
         * @desc contains results from sync Validators, async Validators and ResultValidators
         * @type {Validator[]}
         * @private
         */
        this.__validationResult = [];
        /**
         * @type {Validator[]}
         * @private
         */
        this.__prevValidationResult = [];
        /** @type {Validator[]} */
        this.__prevShownValidationResult = [];

        /** @private */
        this.__onValidatorUpdated = this.__onValidatorUpdated.bind(this);
        /** @protected */
        this._updateFeedbackComponent = this._updateFeedbackComponent.bind(this);

        /**
         * This will be used for FormGroups that listen for `model-value-changed` of children
         * @private
         */
        this.__childModelValueChanged = false;
      }

      connectedCallback() {
        super.connectedCallback();
        localize.addEventListener('localeChanged', this._updateFeedbackComponent);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        localize.removeEventListener('localeChanged', this._updateFeedbackComponent);
      }

      /**
       * @param {import('@lion/core').PropertyValues} changedProperties
       */
      firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this.__validateInitialized = true;
        this.validate();
        if (this._repropagationRole !== 'child') {
          this.addEventListener('model-value-changed', () => {
            this.__childModelValueChanged = true;
          });
        }
      }

      /**
       * @param {string} name
       * @param {?} oldValue
       */
      updateSync(name, oldValue) {
        super.updateSync(name, oldValue);
        if (name === 'validators') {
          // trigger validation (ideally only for the new or changed validator)
          this.__setupValidators();
          this.validate({ clearCurrentResult: true });
        } else if (name === 'modelValue') {
          this.validate({ clearCurrentResult: true });
        }

        if (
          [
            'touched',
            'dirty',
            'prefilled',
            'focused',
            'submitted',
            'hasFeedbackFor',
            'filled',
          ].includes(name)
        ) {
          this._updateShouldShowFeedbackFor();
        }

        if (name === 'showsFeedbackFor') {
          // This can't be reflected asynchronously in Safari
          // Screen reader output should be in sync with visibility of error messages
          if (this._inputNode) {
            this._inputNode.setAttribute('aria-invalid', `${this._hasFeedbackVisibleFor('error')}`);
            // this._inputNode.setCustomValidity(this._validationMessage || '');
          }

          const diff = arrayDiff(this.showsFeedbackFor, oldValue);
          if (diff.length > 0) {
            this.dispatchEvent(new Event(`showsFeedbackForChanged`, { bubbles: true }));
          }
          diff.forEach(type => {
            this.dispatchEvent(
              new Event(`showsFeedbackFor${pascalCase(type)}Changed`, { bubbles: true }),
            );
          });
        }

        if (name === 'shouldShowFeedbackFor') {
          const diff = arrayDiff(this.shouldShowFeedbackFor, oldValue);
          if (diff.length > 0) {
            this.dispatchEvent(new Event(`shouldShowFeedbackForChanged`, { bubbles: true }));
          }
        }
      }

      /**
       * @desc The main function of this mixin. Triggered by:
       *  - a modelValue change
       *  - a change in the 'validators' array
       * -  a change in the config of an individual Validator
       *
       * Three situations are handled:
       * - A.1 The FormControl is empty: further execution is halted. When the Required Validator
       * (being mutually exclusive to the other Validators) is applied, it will end up in the
       * validation result (as the only Validator, since further execution was halted).
       * - A.2 There are synchronous Validators: this is the most common flow. When modelValue hasn't
       * changed since last async results were generated, 'sync results' are merged with the
       * 'async results'.
       * - A.3 There are asynchronous Validators: for instance when server side evaluation is needed.
       * Executions are scheduled and awaited and the 'async results' are merged with the
       * 'sync results'.
       *
       * - B. There are ResultValidators. After steps A.1, A.2, or A.3 are finished, the holistic
       * ResultValidators (evaluating the total result of the 'regular' (A.1, A.2 and A.3) validators)
       * will be run...
       *
       * Situations A.2 and A.3 are not mutually exclusive and can be triggered within one validate()
       * call. Situation B will occur after every call.
       *
       * @param {{ clearCurrentResult?: boolean }} [opts]
       */
      async validate({ clearCurrentResult } = {}) {
        if (this.disabled) {
          this.__clearValidationResults();
          this.__finishValidation({ source: 'sync', hasAsync: true });
          this._updateFeedbackComponent();
          return;
        }
        if (!this.__validateInitialized) {
          return;
        }

        this.__prevValidationResult = this.__validationResult;
        if (clearCurrentResult) {
          // Clear ('invalidate') all pending and existing validation results.
          // This is needed because we have async (pending) validators whose results
          // need to be merged with those of sync validators and vice versa.
          this.__clearValidationResults();
        }
        await this.__executeValidators();
      }

      /**
       * @desc step A1-3 + B (as explained in 'validate')
       */
      async __executeValidators() {
        this.validateComplete = new Promise(resolve => {
          this.__validateCompleteResolve = resolve;
        });

        // When the modelValue can't be created by FormatMixin.parser, still allow all validators
        // to give valuable feedback to the user based on the current viewValue.
        const value =
          this.modelValue instanceof Unparseable ? this.modelValue.viewValue : this.modelValue;

        /** @type {Validator | undefined} */
        const requiredValidator = this._allValidators.find(v => v instanceof Required);

        /**
         * 1. Handle the 'exceptional' Required validator:
         * - the validatity is dependent on the formControl type and therefore determined
         * by the formControl.__isEmpty method. Basically, the Required Validator is a means
         * to trigger formControl.__isEmpty.
         * - when __isEmpty returns true, the input was empty. This means we need to stop
         * validation here, because all other Validators' execute functions assume the
         * value is not empty (there would be nothing to validate).
         */
        // TODO: Try to remove this when we have a single lion form core package, because then we can
        // depend on FormControlMixin directly, and _isEmpty will always be an existing method on the prototype then
        const isEmpty = this.__isEmpty(value);
        if (isEmpty) {
          if (requiredValidator) {
            this.__syncValidationResult = [requiredValidator];
          }
          this.__finishValidation({ source: 'sync' });
          return;
        }

        // Separate Validators in sync and async
        const /** @type {Validator[]} */ filteredValidators = this._allValidators.filter(
            v => !(v instanceof ResultValidator) && !(v instanceof Required),
          );
        const /** @type {Validator[]} */ syncValidators = filteredValidators.filter(v => {
            const vCtor = /** @type {typeof Validator} */ (v.constructor);
            return !vCtor.async;
          });
        const /** @type {Validator[]} */ asyncValidators = filteredValidators.filter(v => {
            const vCtor = /** @type {typeof Validator} */ (v.constructor);
            return vCtor.async;
          });

        /**
         * 2. Synchronous validators
         */
        this.__executeSyncValidators(syncValidators, value, {
          hasAsync: Boolean(asyncValidators.length),
        });

        /**
         * 3. Asynchronous validators
         */
        await this.__executeAsyncValidators(asyncValidators, value);
      }

      /**
       * @desc step A2, calls __finishValidation
       * @param {Validator[]} syncValidators
       * @param {unknown} value
       * @param {{ hasAsync: boolean }} opts
       * @private
       */
      __executeSyncValidators(syncValidators, value, { hasAsync }) {
        if (syncValidators.length) {
          this.__syncValidationResult = syncValidators.filter(v =>
            v.execute(value, v.param, { node: this }),
          );
        }
        this.__finishValidation({ source: 'sync', hasAsync });
      }

      /**
       * @desc step A3, calls __finishValidation
       * @param {Validator[]} asyncValidators all Validators except required and ResultValidators
       * @param {?} value
       * @private
       */
      async __executeAsyncValidators(asyncValidators, value) {
        if (asyncValidators.length) {
          this.isPending = true;
          const resultPromises = asyncValidators.map(v => v.execute(value, v.param, { node: this }));
          const booleanResults = await Promise.all(resultPromises);
          this.__asyncValidationResult = booleanResults
            .map((r, i) => asyncValidators[i]) // Create an array of Validators
            .filter((v, i) => booleanResults[i]); // Only leave the ones returning true
          this.__finishValidation({ source: 'async' });
          this.isPending = false;
        }
      }

      /**
       * @desc step B, called by __finishValidation
       * @param {Validator[]} regularValidationResult result of steps 1-3
       * @private
       */
      __executeResultValidators(regularValidationResult) {
        const resultValidators = /** @type {ResultValidator[]} */ (this._allValidators.filter(v => {
          const vCtor = /** @type {typeof Validator} */ (v.constructor);
          return !vCtor.async && v instanceof ResultValidator;
        }));

        return resultValidators.filter(v =>
          v.executeOnResults({
            regularValidationResult,
            prevValidationResult: this.__prevValidationResult,
            prevShownValidationResult: this.__prevShownValidationResult,
          }),
        );
      }

      /**
       * @param {object} options
       * @param {'sync'|'async'} options.source
       * @param {boolean} [options.hasAsync] whether async validators are configured in this run.
       * @private
       * If not, we have nothing left to wait for.
       */
      __finishValidation({ source, hasAsync }) {
        const syncAndAsyncOutcome = [...this.__syncValidationResult, ...this.__asyncValidationResult];
        // if we have any ResultValidators left, now is the time to run them...
        const resultOutCome = this.__executeResultValidators(syncAndAsyncOutcome);

        this.__validationResult = [...resultOutCome, ...syncAndAsyncOutcome];
        // this._storeResultsOnInstance(this.__validationResult);

        const ctor = /** @type {typeof import('../../types/validate/ValidateMixinTypes').ValidateHost} */ (this
          .constructor);

        /** @type {Object.<string, Object.<string, boolean>>} */
        const validationStates = ctor.validationTypes.reduce(
          (acc, type) => ({ ...acc, [type]: {} }),
          {},
        );
        this.__validationResult.forEach(v => {
          if (!validationStates[v.type]) {
            validationStates[v.type] = {};
          }
          const vCtor = /** @type {typeof Validator} */ (v.constructor);
          validationStates[v.type][vCtor.validatorName] = true;
        });
        this.validationStates = validationStates;

        this.hasFeedbackFor = [...new Set(this.__validationResult.map(v => v.type))];

        /** private event that should be listened to by LionFieldSet */
        this.dispatchEvent(new Event('validate-performed', { bubbles: true }));
        if (source === 'async' || !hasAsync) {
          if (this.__validateCompleteResolve) {
            // @ts-ignore [allow-private]
            this.__validateCompleteResolve();
          }
        }
      }

      /**
       * @private
       */
      __clearValidationResults() {
        this.__syncValidationResult = [];
        this.__asyncValidationResult = [];
      }

      /**
       * @param {Event|CustomEvent} e
       * @private
       */
      __onValidatorUpdated(e) {
        if (e.type === 'param-changed' || e.type === 'config-changed') {
          this.validate();
        }
      }

      /**
       * @private
       */
      __setupValidators() {
        const events = ['param-changed', 'config-changed'];
        if (this.__prevValidators) {
          this.__prevValidators.forEach(v => {
            events.forEach(e => {
              if (v.removeEventListener) {
                v.removeEventListener(e, this.__onValidatorUpdated);
              }
            });
            v.onFormControlDisconnect(this);
          });
        }
        this._allValidators.forEach(v => {
          if (!(v instanceof Validator)) {
            // throws in constructor are not visible to end user so we do both
            const errorType = Array.isArray(v) ? 'array' : typeof v;
            const errorMessage = `Validators array only accepts class instances of Validator. Type "${errorType}" found. This may be caused by having multiple installations of @lion/form-core.`;
            // eslint-disable-next-line no-console
            console.error(errorMessage, this);
            throw new Error(errorMessage);
          }
          const ctor = /** @type {typeof import('../../types/validate/ValidateMixinTypes').ValidateHost} */ (this
            .constructor);
          if (ctor.validationTypes.indexOf(v.type) === -1) {
            const vCtor = /** @type {typeof Validator} */ (v.constructor);
            // throws in constructor are not visible to end user so we do both
            const errorMessage = `This component does not support the validator type "${v.type}" used in "${vCtor.validatorName}". You may change your validators type or add it to the components "static get validationTypes() {}".`;
            // eslint-disable-next-line no-console
            console.error(errorMessage, this);
            throw new Error(errorMessage);
          }
          events.forEach(e => {
            if (v.addEventListener) {
              v.addEventListener(e, this.__onValidatorUpdated);
            }
          });
          v.onFormControlConnect(this);
        });
        this.__prevValidators = this._allValidators;
      }

      /**
       * @param {?} v
       * @private
       */
      __isEmpty(v) {
        if (typeof this._isEmpty === 'function') {
          return this._isEmpty(v);
        }
        return (
          this.modelValue === null || typeof this.modelValue === 'undefined' || this.modelValue === ''
        );
      }

      // ------------------------------------------------------------------------------------------
      // -- Feedback specifics --------------------------------------------------------------------
      // ------------------------------------------------------------------------------------------

      /**
       * @typedef {object} FeedbackMessage
       * @property {string | Node} message this
       * @property {string} type will be 'error' for messages from default Validators. Could be
       * 'warning', 'info' etc. for Validators with custom types. Needed as a directive for
       * feedbackNode how to render a message of a certain type
       * @property {Validator} [validator] when the message is directly coupled to a Validator
       * (in most cases), this property is filled. When a message is not coupled to a Validator
       * (in case of success feedback which is based on a diff or current and previous validation
       * results), this property can be left empty.
       */

      /**
       * @param {Validator[]} validators list of objects having a .getMessage method
       * @return {Promise.<FeedbackMessage[]>}
       * @private
       */
      async __getFeedbackMessages(validators) {
        let fieldName = await this.fieldName;
        return Promise.all(
          validators.map(async validator => {
            if (validator.config.fieldName) {
              fieldName = await validator.config.fieldName;
            }
            // @ts-ignore [allow-protected]
            const message = await validator._getMessage({
              modelValue: this.modelValue,
              formControl: this,
              fieldName,
            });
            return { message, type: validator.type, validator };
          }),
        );
      }

      /**
       * @desc Responsible for retrieving messages from Validators and
       * (delegation of) rendering them.
       *
       * For `._feedbackNode` (extension of LionValidationFeedback):
       * - retrieve messages from highest prio Validators
       * - provide the result to custom feedback node and let the
       * custom node decide on their renderings
       *
       * In both cases:
       * - we compute the 'show' flag (like 'hasErrorVisible') for all types
       * - we set the customValidity message of the highest prio Validator
       * - we set aria-invalid="true" in case hasErrorVisible is true
       * @protected
       */
      _updateFeedbackComponent() {
        const { _feedbackNode } = this;
        if (!_feedbackNode) {
          return;
        }

        if (!this.__feedbackQueue) {
          this.__feedbackQueue = new AsyncQueue();
        }

        if (this.showsFeedbackFor.length > 0) {
          this.__feedbackQueue.add(async () => {
            /** @type {Validator[]} */
            this.__prioritizedResult = this._prioritizeAndFilterFeedback({
              validationResult: this.__validationResult,
            });

            if (this.__prioritizedResult.length > 0) {
              this.__prevShownValidationResult = this.__prioritizedResult;
            }

            const messageMap = await this.__getFeedbackMessages(this.__prioritizedResult);
            _feedbackNode.feedbackData = messageMap.length ? messageMap : [];
          });
        } else {
          this.__feedbackQueue.add(async () => {
            _feedbackNode.feedbackData = [];
          });
        }
        this.feedbackComplete = this.__feedbackQueue.complete;
      }

      /**
       * The default feedbackCondition condition that will be used when the
       * feedbackCondition is not overridden.
       * Show the validity feedback when returning true, don't show when false
       * @param {string} type could be 'error', 'warning', 'info', 'success' or any other custom
       * Validator type
       * @param {object} meta meta info (interaction states etc)
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      _showFeedbackConditionFor(type, meta) {
        return true;
      }

      /**
       * Allows super classes to add meta info for feedbackCondition
       * @configurable
       */
      get _feedbackConditionMeta() {
        return { modelValue: this.modelValue, el: this };
      }

      /**
       * Allows the end user to specify when a feedback message should be shown
       * @example
       * feedbackCondition(type, meta, defaultCondition) {
       *   if (type === 'info') {
       *     return return;
       *   } else if (type === 'prefilledOnly') {
       *     return meta.prefilled;
       *   }
       *   return defaultCondition(type, meta);
       * }
       * @overridable
       * @param {string} type could be 'error', 'warning', 'info', 'success' or any other custom
       * Validator type
       * @param {object} meta meta info (interaction states etc)
       * @param {((type: string, meta: object) => boolean)} currentCondition this is the _showFeedbackConditionFor
       * that can be used if a developer wants to override for a certain type, but wants to fallback
       * for other types
       * @returns {boolean}
       */
      feedbackCondition(
        type,
        meta = this._feedbackConditionMeta,
        currentCondition = this._showFeedbackConditionFor.bind(this),
      ) {
        return currentCondition(type, meta);
      }

      /**
       * @param {string} type
       * @protected
       */
      _hasFeedbackVisibleFor(type) {
        return (
          this.hasFeedbackFor &&
          this.hasFeedbackFor.includes(type) &&
          this.shouldShowFeedbackFor &&
          this.shouldShowFeedbackFor.includes(type)
        );
      }

      /** @param {import('@lion/core').PropertyValues} changedProperties */
      updated(changedProperties) {
        super.updated(changedProperties);

        if (
          changedProperties.has('shouldShowFeedbackFor') ||
          changedProperties.has('hasFeedbackFor')
        ) {
          const ctor = /** @type {typeof import('../../types/validate/ValidateMixinTypes').ValidateHost} */ (this
            .constructor);
          // Necessary typecast because types aren't smart enough to understand that we filter out undefined
          this.showsFeedbackFor = /** @type {string[]} */ (ctor.validationTypes
            .map(type => (this._hasFeedbackVisibleFor(type) ? type : undefined))
            .filter(Boolean));
          this._updateFeedbackComponent();
        }

        if (changedProperties.has('__childModelValueChanged') && this.__childModelValueChanged) {
          this.validate({ clearCurrentResult: true });
          this.__childModelValueChanged = false;
        }

        if (changedProperties.has('validationStates')) {
          const prevStates = /** @type {{[key: string]: object;}} */ (changedProperties.get(
            'validationStates',
          ));
          if (prevStates) {
            Object.entries(this.validationStates).forEach(([type, feedbackObj]) => {
              if (
                prevStates[type] &&
                JSON.stringify(feedbackObj) !== JSON.stringify(prevStates[type])
              ) {
                this.dispatchEvent(new CustomEvent(`${type}StateChanged`, { detail: feedbackObj }));
              }
            });
          }
        }
      }

      /**
       * @protected
       */
      _updateShouldShowFeedbackFor() {
        const ctor = /** @type {typeof import('../../types/validate/ValidateMixinTypes').ValidateHost} */ (this
          .constructor);

        // Necessary typecast because types aren't smart enough to understand that we filter out undefined
        const newShouldShowFeedbackFor = /** @type {string[]} */ (ctor.validationTypes
          .map(type =>
            this.feedbackCondition(
              type,
              this._feedbackConditionMeta,
              this._showFeedbackConditionFor.bind(this),
            )
              ? type
              : undefined,
          )
          .filter(Boolean));

        if (JSON.stringify(this.shouldShowFeedbackFor) !== JSON.stringify(newShouldShowFeedbackFor)) {
          this.shouldShowFeedbackFor = newShouldShowFeedbackFor;
        }
      }

      /**
       * @overridable
       * @desc Orders all active validators in this.__validationResult. Can
       * also filter out occurrences (based on interaction states)
       * @param {{ validationResult: Validator[] }} opts
       * @return {Validator[]} ordered list of Validators with feedback messages visible to the
       * @protected
       * end user
       */
      _prioritizeAndFilterFeedback({ validationResult }) {
        const ctor = /** @type {typeof import('../../types/validate/ValidateMixinTypes').ValidateHost} */ (this
          .constructor);
        const types = ctor.validationTypes;
        // Sort all validators based on the type provided.
        const res = validationResult
          .filter(v =>
            this.feedbackCondition(
              v.type,
              this._feedbackConditionMeta,
              this._showFeedbackConditionFor.bind(this),
            ),
          )
          .sort((a, b) => types.indexOf(a.type) - types.indexOf(b.type));
        return res.slice(0, this._visibleMessagesAmount);
      }
    };

  const ValidateMixin = dedupeMixin(ValidateMixinImplementation);

  /* eslint-disable class-methods-use-this */

  /**
   * @typedef {import('../types/FormatMixinTypes').FormatMixin} FormatMixin
   * @typedef {import('@lion/localize/types/LocalizeMixinTypes').FormatNumberOptions} FormatOptions
   * @typedef {import('../types/FormControlMixinTypes.js').ModelValueEventDetails} ModelValueEventDetails
   */

  // For a future breaking release:
  // - do not allow the private `.formattedValue` as property that can be set to
  // trigger a computation loop.
  // - do not fire events for those private and protected concepts
  // - simplify _calculateValues: recursive trigger lock can be omitted, since need for connecting
  // the loop via sync observers is not needed anymore.
  // - consider `formatOn` as an overridable function, by default something like:
  // `(!_isHandlingUserInput || !hasError) && !focused`
  // This would allow for more advanced scenarios, like formatting an input whenever it becomes valid.
  // This would make formattedValue as a concept obsolete, since for maximum flexibility, the
  // formattedValue condition needs to be evaluated right before syncing back to the view

  /**
   * @desc Designed to be applied on top of a LionField.
   * To understand all concepts within the Mixin, please consult the flow diagram in the
   * documentation.
   *
   * ## Flows
   * FormatMixin supports these two main flows:
   * [1] Application Developer sets `.modelValue`:
   *     Flow: `.modelValue` (formatter) -> `.formattedValue` -> `._inputNode.value`
   *                         (serializer) -> `.serializedValue`
   * [2] End user interacts with field:
   *     Flow: `@user-input-changed` (parser) -> `.modelValue` (formatter) -> `.formattedValue` - (debounce till reflect condition (formatOn) is met) -> `._inputNode.value`
   *                                 (serializer) -> `.serializedValue`
   *
   * For backwards compatibility with the platform, we also support `.value` as an api. In that case
   * the flow will be like [2], without the debounce.
   *
   * ## Difference between value, viewValue and formattedValue
   * A viewValue is a concept rather than a property. To be compatible with the platform api, the
   * property for the concept of viewValue is thus called `.value`.
   * When reading code and docs, one should be aware that the term viewValue is mostly used, but the
   * terms can be used interchangeably.
   * The `.formattedValue` should be seen as the 'scheduled' viewValue. It is computed realtime and
   * stores the output of formatter. It will replace viewValue. once condition `formatOn` is met.
   * Another difference is that formattedValue lives on `LionField`, whereas viewValue is shared
   * across `LionField` and `._inputNode`.
   *
   * For restoring serialized values fetched from a server, we could consider one extra flow:
   * [3] Application Developer sets `.serializedValue`:
   *     Flow: serializedValue (deserializer) -> `.modelValue` (formatter) -> `.formattedValue` -> `._inputNode.value`
   *
   * @type {FormatMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   */
  const FormatMixinImplementation = superclass =>
    class FormatMixin extends ValidateMixin(FormControlMixin(superclass)) {
      /** @type {any} */
      static get properties() {
        return {
          /**
           * The view value is the result of the formatter function (when available).
           * The result will be stored in the native _inputNode (usually an input[type=text]).
           *
           * Examples:
           * - For a date input, this would be '20/01/1999' (dependent on locale).
           * - For a number input, this could be '1,234.56' (a String representation of modelValue
           * 1234.56)
           *
           * @private
           */
          formattedValue: { attribute: false },

          /**
           * The serialized version of the model value.
           * This value exists for maximal compatibility with the platform API.
           * The serialized value can be an interface in context where data binding is not
           * supported and a serialized string needs to be set.
           *
           * Examples:
           * - For a date input, this would be the iso format of a date, e.g. '1999-01-20'.
           * - For a number input this would be the String representation of a float ('1234.56'
           *   instead of 1234.56)
           *
           * When no parser is available, the value is usually the same as the formattedValue
           * (being _inputNode.value)
           *
           */
          serializedValue: { attribute: false },

          /**
           * Event that will trigger formatting (more precise, visual update of the view, so the
           * user sees the formatted value)
           * Default: 'change'
           */
          formatOn: { attribute: false },

          /**
           * Configuration object that will be available inside the formatter function
           */
          formatOptions: { attribute: false },
        };
      }

      /**
       * @param {string} name
       * @param {any} oldVal
       */
      requestUpdateInternal(name, oldVal) {
        super.requestUpdateInternal(name, oldVal);

        if (name === 'modelValue' && this.modelValue !== oldVal) {
          this._onModelValueChanged({ modelValue: this.modelValue }, { modelValue: oldVal });
        }
        if (name === 'serializedValue' && this.serializedValue !== oldVal) {
          this._calculateValues({ source: 'serialized' });
        }
        if (name === 'formattedValue' && this.formattedValue !== oldVal) {
          this._calculateValues({ source: 'formatted' });
        }
      }

      get value() {
        return (this._inputNode && this._inputNode.value) || this.__value || '';
      }

      // We don't delegate, because we want to preserve caret position via _setValueAndPreserveCaret
      /** @param {string} value */
      set value(value) {
        // if not yet connected to dom can't change the value
        if (this._inputNode) {
          this._inputNode.value = value;
          /** @type {string | undefined} */
          this.__value = undefined;
        } else {
          this.__value = value;
        }
      }

      /**
       * @param {string} v - the raw value from the <input> after keyUp/Down event
       * @returns {string} preprocessedValue: the result of preprocessing for invalid input
       */
      preprocessor(v) {
        return v;
      }

      /**
       * Converts formattedValue to modelValue
       * For instance, a localized date to a Date Object
       * @param {string} v - formattedValue: the formatted value inside <input>
       * @param {FormatOptions} opts
       * @returns {*} modelValue
       */
      // eslint-disable-next-line no-unused-vars
      parser(v, opts) {
        return v;
      }

      /**
       * Converts modelValue to formattedValue (formattedValue will be synced with
       * `._inputNode.value`)
       * For instance, a Date object to a localized date.
       * @param {*} v - modelValue: can be an Object, Number, String depending on the
       * input type(date, number, email etc)
       * @param {FormatOptions} opts
       * @returns {string} formattedValue
       */
      // eslint-disable-next-line no-unused-vars
      formatter(v, opts) {
        return v;
      }

      /**
       * Converts `.modelValue` to `.serializedValue`
       * For instance, a Date object to an iso formatted date string
       * @param {?} v - modelValue: can be an Object, Number, String depending on the
       * input type(date, number, email etc)
       * @returns {string} serializedValue
       */
      serializer(v) {
        return v !== undefined ? v : '';
      }

      /**
       * Converts `LionField.value` to `.modelValue`
       * For instance, an iso formatted date string to a Date object
       * @param {?} v - modelValue: can be an Object, Number, String depending on the
       * input type(date, number, email etc)
       * @returns {?} modelValue
       */
      deserializer(v) {
        return v === undefined ? '' : v;
      }

      /**
       * Responsible for storing all representations(modelValue, serializedValue, formattedValue
       * and value) of the input value. Prevents infinite loops, so all value observers can be
       * treated like they will only be called once, without indirectly calling other observers.
       * (in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the
       * second call from having effect).
       *
       * @param {{source:'model'|'serialized'|'formatted'|null}} config - the type of value that triggered this method. It should not be
       * set again, so that its observer won't be triggered. Can be:
       * 'model'|'formatted'|'serialized'.
       * @protected
       */
      _calculateValues({ source } = { source: null }) {
        if (this.__preventRecursiveTrigger) return; // prevent infinite loops

        /** @type {boolean} */
        this.__preventRecursiveTrigger = true;
        if (source !== 'model') {
          if (source === 'serialized') {
            /** @type {?} */
            this.modelValue = this.deserializer(this.serializedValue);
          } else if (source === 'formatted') {
            this.modelValue = this._callParser();
          }
        }
        if (source !== 'formatted') {
          /** @type {string} */
          this.formattedValue = this._callFormatter();
        }
        if (source !== 'serialized') {
          /** @type {string} */
          this.serializedValue = this.serializer(this.modelValue);
        }
        this._reflectBackFormattedValueToUser();
        this.__preventRecursiveTrigger = false;
      }

      /**
       * @param {string|undefined} value
       * @return {?}
       * @private
       */
      _callParser(value = this.formattedValue) {
        // A) check if we need to parse at all

        // A.1) The end user had no intention to parse
        if (value === '') {
          // Ideally, modelValue should be undefined for empty strings.
          // For backwards compatibility we return an empty string:
          // - it triggers validation for required validators (see ValidateMixin.validate())
          // - it can be expected by 3rd parties (for instance unit tests)
          // TODO(@tlouisse): In a breaking refactor of the Validation System, this behavior can be corrected.
          return '';
        }

        // A.2) Handle edge cases We might have no view value yet, for instance because
        // _inputNode.value was not available yet
        if (typeof value !== 'string') {
          // This means there is nothing to find inside the view that can be of
          // interest to the Application Developer or needed to store for future
          // form state retrieval.
          return undefined;
        }

        // B) parse the view value

        // - if result:
        // return the successfully parsed viewValue
        // - if no result:
        // Apparently, the parser was not able to produce a satisfactory output for the desired
        // modelValue type, based on the current viewValue. Unparseable allows to restore all
        // states (for instance from a lost user session), since it saves the current viewValue.
        const result = this.parser(value, this.formatOptions);
        return result !== undefined ? result : new Unparseable(value);
      }

      /**
       * @returns {string|undefined}
       * @private
       */
      _callFormatter() {
        // - Why check for this.hasError?
        // We only want to format values that are considered valid. For best UX,
        // we only 'reward' valid inputs.
        // - Why check for _isHandlingUserInput?
        // Downwards sync is prevented whenever we are in an `@user-input-changed` flow, [2].
        // If we are in a 'imperatively set `.modelValue`' flow, [1], we want to reflect back
        // the value, no matter what.
        // This means, whenever we are in hasError and modelValue is set
        // imperatively, we DO want to format a value (it is the only way to get meaningful
        // input into `._inputNode` with modelValue as input)

        if (
          this._isHandlingUserInput &&
          this.hasFeedbackFor &&
          this.hasFeedbackFor.length &&
          this.hasFeedbackFor.includes('error') &&
          this._inputNode
        ) {
          return this._inputNode ? this.value : undefined;
        }

        if (this.modelValue instanceof Unparseable) {
          // When the modelValue currently is unparseable, we need to sync back the supplied
          // viewValue. In flow [2], this should not be needed.
          // In flow [1] (we restore a previously stored modelValue) we should sync down, however.
          return this.modelValue.viewValue;
        }

        return this.formatter(this.modelValue, this.formatOptions);
      }

      /**
       * Observer Handlers
       * @param {{ modelValue: unknown; }[]} args
       * @protected
       */
      _onModelValueChanged(...args) {
        this._calculateValues({ source: 'model' });
        this._dispatchModelValueChangedEvent(...args);
      }

      /**
       * @param {{ modelValue: unknown; }[]} args
       * This is wrapped in a distinct method, so that parents can control when the changed event
       * is fired. For objects, a deep comparison might be needed.
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      _dispatchModelValueChangedEvent(...args) {
        /** @event model-value-changed */
        this.dispatchEvent(
          new CustomEvent('model-value-changed', {
            bubbles: true,
            detail: /** @type { ModelValueEventDetails } */ ({
              formPath: [this],
              isTriggeredByUser: Boolean(this._isHandlingUserInput),
            }),
          }),
        );
      }

      /**
       * Synchronization from `._inputNode.value` to `LionField` (flow [2])
       * Downwards syncing should only happen for `LionField`.value changes from 'above'.
       * This triggers _onModelValueChanged and connects user input
       * to the parsing/formatting/serializing loop.
       * @protected
       */
      _syncValueUpwards() {
        if (!this.__isHandlingComposition) {
          this.value = this.preprocessor(this.value);
        }
        const prevFormatted = this.formattedValue;
        this.modelValue = this._callParser(this.value);

        // Sometimes, the formattedValue didn't change, but the viewValue did...
        // We need this check to support pasting values that need to be formatted right on paste
        if (prevFormatted === this.formattedValue && this.__prevViewValue !== this.value) {
          this._calculateValues();
        }
        /** @type {string} */
        this.__prevViewValue = this.value;
      }

      /**
       * Synchronization from `LionField.value` to `._inputNode.value`
       * - flow [1] will always be reflected back
       * - flow [2] will not be reflected back when this flow was triggered via
       *   `@user-input-changed` (this will happen later, when `formatOn` condition is met)
       * @protected
       */
      _reflectBackFormattedValueToUser() {
        if (this._reflectBackOn()) {
          // Text 'undefined' should not end up in <input>
          this.value = typeof this.formattedValue !== 'undefined' ? this.formattedValue : '';
        }
      }

      /**
       * Every time .formattedValue is attempted to sync to the view value (on change/blur and on
       * modelValue change), this condition is checked. When enhancing it, it's recommended to
       * call `super._reflectBackOn()`
       * @overridable
       * @return {boolean}
       * @protected
       */
      _reflectBackOn() {
        return !this._isHandlingUserInput;
      }

      /**
       * This can be called whenever the view value should be updated. Dependent on component type
       * ("input" for <input> or "change" for <select>(mainly for IE)) a different event should be
       * used  as source for the "user-input-changed" event (which can be seen as an abstraction
       * layer on top of other events (input, change, whatever))
       * @protected
       */
      _proxyInputEvent() {
        this.dispatchEvent(
          new CustomEvent('user-input-changed', {
            bubbles: true,
            composed: true,
          }),
        );
      }

      /** @protected */
      _onUserInputChanged() {
        // Upwards syncing. Most properties are delegated right away, value is synced to
        // `LionField`, to be able to act on (imperatively set) value changes
        this._isHandlingUserInput = true;
        this._syncValueUpwards();
        this._isHandlingUserInput = false;
      }

      /**
       * @param {Event} event
       */
      __onCompositionEvent({ type }) {
        if (type === 'compositionstart') {
          this.__isHandlingComposition = true;
        } else if (type === 'compositionend') {
          this.__isHandlingComposition = false;
          // in all other cases this would be triggered via user-input-changed
          this._syncValueUpwards();
        }
      }

      constructor() {
        super();
        this.formatOn = 'change';
        this.formatOptions = /** @type {FormatOptions} */ ({});
        /**
         * Whether the user is pasting content. Allows Subclassers to do this in their subclass:
         * @example
         * ```js
         * _reflectBackOn() {
         *   return super._reflectBackOn() || this._isPasting;
         * }
         * ```
         * @protected
         */
        this._isPasting = false;
        /**
         * @private
         * @type {string}
         */
        this.__prevViewValue = '';
        this.__onCompositionEvent = this.__onCompositionEvent.bind(this);
        // This computes formattedValue
        this.addEventListener('user-input-changed', this._onUserInputChanged);
        // This sets the formatted viewValue after paste
        this.addEventListener('paste', this.__onPaste);
      }

      __onPaste() {
        this._isPasting = true;
        this.formatOptions.mode = 'pasted';
        setTimeout(() => {
          this._isPasting = false;
          this.formatOptions.mode = 'auto';
        });
      }

      connectedCallback() {
        super.connectedCallback();
        this._reflectBackFormattedValueToUser = this._reflectBackFormattedValueToUser.bind(this);

        this._reflectBackFormattedValueDebounced = () => {
          // Make sure this is fired after the change event of _inputNode, so that formattedValue
          // is guaranteed to be calculated
          setTimeout(this._reflectBackFormattedValueToUser);
        };

        // Connect the value found in <input> to the formatting/parsing/serializing loop as a
        // fallback mechanism. Assume the user uses the value property of the
        // `LionField`(recommended api) as the api (this is a downwards sync).
        // However, when no value is specified on `LionField`, have support for sync of the real
        // input to the `LionField` (upwards sync).
        if (typeof this.modelValue === 'undefined') {
          this._syncValueUpwards();
        }
        this._reflectBackFormattedValueToUser();

        if (this._inputNode) {
          this._inputNode.addEventListener(this.formatOn, this._reflectBackFormattedValueDebounced);
          this._inputNode.addEventListener('input', this._proxyInputEvent);
          this._inputNode.addEventListener('compositionstart', this.__onCompositionEvent);
          this._inputNode.addEventListener('compositionend', this.__onCompositionEvent);
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        if (this._inputNode) {
          this._inputNode.removeEventListener('input', this._proxyInputEvent);
          this._inputNode.removeEventListener(
            this.formatOn,
            /** @type {EventListenerOrEventListenerObject} */ (this
              ._reflectBackFormattedValueDebounced),
          );
          this._inputNode.removeEventListener('compositionstart', this.__onCompositionEvent);
          this._inputNode.removeEventListener('compositionend', this.__onCompositionEvent);
        }
      }
    };

  const FormatMixin = dedupeMixin(FormatMixinImplementation);

  /**
   * @typedef {import('../types/InteractionStateMixinTypes').InteractionStateMixin} InteractionStateMixin
   * @typedef {import('../types/InteractionStateMixinTypes').InteractionStates} InteractionStates
   */

  /**
   * @desc `InteractionStateMixin` adds meta information about touched and dirty states, that can
   * be read by other form components (ing-uic-input-error for instance, uses the touched state
   * to determine whether an error message needs to be shown).
   * Interaction states will be set when a user:
   * - leaves a form field(blur) -> 'touched' will be set to true. 'prefilled' when a
   *   field is left non-empty
   * - on keyup (actually, on the model-value-changed event) -> 'dirty' will be set to true
   *
   * @type {InteractionStateMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass
   */
  const InteractionStateMixinImplementation = superclass =>
    class InteractionStateMixin extends FormControlMixin(superclass) {
      /** @type {any} */
      static get properties() {
        return {
          /**
           * True when user has focused and left(blurred) the field.
           */
          touched: {
            type: Boolean,
            reflect: true,
          },
          /**
           * True when user has changed the value of the field.
           */
          dirty: {
            type: Boolean,
            reflect: true,
          },
          /**
           * True when the modelValue is non-empty (see _isEmpty in FormControlMixin)
           */
          filled: {
            type: Boolean,
            reflect: true,
          },
          /**
           * True when user has left non-empty field or input is prefilled.
           * The name must be seen from the point of view of the input field:
           * once the user enters the input field, the value is non-empty.
           */
          prefilled: {
            attribute: false,
          },
          /**
           * True when user has attempted to submit the form, e.g. through a button
           * of type="submit"
           */
          submitted: {
            attribute: false,
          },
        };
      }

      /**
       *
       * @param {PropertyKey} name
       * @param {*} oldVal
       */
      requestUpdateInternal(name, oldVal) {
        super.requestUpdateInternal(name, oldVal);
        if (name === 'touched' && this.touched !== oldVal) {
          this._onTouchedChanged();
        }

        if (name === 'modelValue') {
          // We do this in requestUpdateInternal because we don't want to fire another re-render (e.g. when doing this in updated)
          // Furthermore, we cannot do it on model-value-changed event because it isn't fired initially.
          this.filled = !this._isEmpty();
        }

        if (name === 'dirty' && this.dirty !== oldVal) {
          this._onDirtyChanged();
        }
      }

      constructor() {
        super();
        this.touched = false;
        this.dirty = false;
        this.prefilled = false;
        this.filled = false;

        /** @type {string} */
        this._leaveEvent = 'blur';
        /** @type {string} */
        this._valueChangedEvent = 'model-value-changed';
        /** @type {EventHandlerNonNull} */
        this._iStateOnLeave = this._iStateOnLeave.bind(this);
        /** @type {EventHandlerNonNull} */
        this._iStateOnValueChange = this._iStateOnValueChange.bind(this);
      }

      /**
       * Register event handlers and validate prefilled inputs
       */
      connectedCallback() {
        super.connectedCallback();
        this.addEventListener(this._leaveEvent, this._iStateOnLeave);
        this.addEventListener(this._valueChangedEvent, this._iStateOnValueChange);
        this.initInteractionState();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener(this._leaveEvent, this._iStateOnLeave);
        this.removeEventListener(this._valueChangedEvent, this._iStateOnValueChange);
      }

      /**
       * Evaluations performed on connectedCallback. Since some components can be out of sync
       * (due to interdependence on light children that can only be processed
       * after connectedCallback and affect the initial value).
       * This method is exposed, so it can be called after they are initialized themselves.
       * Since this method will be called twice in last mentioned scenario, it must stay idempotent.
       */
      initInteractionState() {
        this.dirty = false;
        this.prefilled = !this._isEmpty();
      }

      /**
       * Sets touched value to true
       * Reevaluates prefilled state.
       * When false, on next interaction, user will start with a clean state.
       * @protected
       */
      _iStateOnLeave() {
        this.touched = true;
        this.prefilled = !this._isEmpty();
      }

      /**
       * Sets dirty value and validates when already touched or invalid
       * @protected
       */
      _iStateOnValueChange() {
        this.dirty = true;
      }

      /**
       * Resets touched and dirty, and recomputes prefilled
       */
      resetInteractionState() {
        this.touched = false;
        this.submitted = false;
        this.dirty = false;
        this.prefilled = !this._isEmpty();
      }

      /**
       * Dispatches custom event on touched state change
       * @protected
       */
      _onTouchedChanged() {
        this.dispatchEvent(new CustomEvent('touched-changed', { bubbles: true, composed: true }));
      }

      /**
       * Dispatches custom event on touched state change
       * @protected
       */
      _onDirtyChanged() {
        this.dispatchEvent(new CustomEvent('dirty-changed', { bubbles: true, composed: true }));
      }

      /**
       * Show the validity feedback when one of the following conditions is met:
       *
       * - submitted
       *   If the form is submitted, always show the error message.
       *
       * - prefilled
       *   the user already filled in something, or the value is prefilled
       *   when the form is initially rendered.
       *
       * - touched && dirty
       *   When a user starts typing for the first time in a field with for instance `required`
       *   validation, error message should not be shown until a field becomes `touched`
       *   (a user leaves(blurs) a field).
       *   When a user enters a field without altering the value(making it `dirty`),
       *   an error message shouldn't be shown either.
       * @protected
       * @param {string} type
       * @param {InteractionStates} meta
       */
      // eslint-disable-next-line class-methods-use-this, no-unused-vars
      _showFeedbackConditionFor(type, meta) {
        return (meta.touched && meta.dirty) || meta.prefilled || meta.submitted;
      }

      get _feedbackConditionMeta() {
        return {
          // @ts-ignore to fix, InteractionStateMixin needs to depend on ValidateMixin
          ...super._feedbackConditionMeta,
          submitted: this.submitted,
          touched: this.touched,
          dirty: this.dirty,
          filled: this.filled,
          prefilled: this.prefilled,
        };
      }
    };

  const InteractionStateMixin = dedupeMixin(InteractionStateMixinImplementation);

  /**
   * `LionField`: wraps <input>, <textarea>, <select> and other interactable elements.
   * Also it would follow a nice hierarchy: lion-form -> lion-fieldset -> lion-field
   *
   * Note: We don't support placeholders, because we have a helper text and
   * placeholders confuse the user with accessibility needs.
   *
   * Please see the docs for in depth information.
   *
   * @example
   * <lion-field name="myName">
   *   <label slot="label">My Input</label>
   *   <input type="text" slot="input">
   * </lion-field>
   *
   * @customElement lion-field
   */
  class LionField extends FormControlMixin(
    InteractionStateMixin(FocusMixin(FormatMixin(ValidateMixin(SlotMixin(LitElement))))),
  ) {
    /** @type {any} */
    static get properties() {
      return {
        autocomplete: {
          type: String,
          reflect: true,
        },
        value: {
          type: String,
        },
      };
    }

    constructor() {
      super();
      this.name = '';
      /** @type {string | undefined} */
      this.autocomplete = undefined;
    }

    /**
     * @param {import('@lion/core').PropertyValues } changedProperties
     */
    firstUpdated(changedProperties) {
      super.firstUpdated(changedProperties);
      /** @type {any} */
      this._initialModelValue = this.modelValue;
    }

    connectedCallback() {
      super.connectedCallback();
      this._onChange = this._onChange.bind(this);
      this._inputNode.addEventListener('change', this._onChange);
      this.classList.add('form-field'); // eslint-disable-line
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this._inputNode.removeEventListener('change', this._onChange);
    }

    resetInteractionState() {
      super.resetInteractionState();
      this.submitted = false;
    }

    /**
     * Resets modelValue to initial value.
     * Interaction states are cleared
     */
    reset() {
      this.modelValue = this._initialModelValue;
      this.resetInteractionState();
    }

    /**
     * Clears modelValue.
     * Interaction states are not cleared (use resetInteractionState for this)
     */
    clear() {
      this.modelValue = ''; // can't set null here, because IE11 treats it as a string
    }

    /**
     * Dispatches custom bubble event
     * @protected
     */
    _onChange() {
      this.dispatchEvent(
        new CustomEvent('user-input-changed', {
          bubbles: true,
        }),
      );
    }

    /**
     * @configure InteractionStateMixin, ValidateMixin
     */
    get _feedbackConditionMeta() {
      return { ...super._feedbackConditionMeta, focused: this.focused };
    }
  }

  /**
   * @typedef {import('../types/NativeTextFieldMixinTypes').NativeTextFieldMixin} NativeTextFieldMixin
   * @type {NativeTextFieldMixin}
   * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass} superclass
   */
  const NativeTextFieldMixinImplementation = superclass =>
    class NativeTextFieldMixin extends FormatMixin(FocusMixin(FormControlMixin(superclass))) {
      /**
       * @protected
       * @type {HTMLInputElement | HTMLTextAreaElement}
       */
      get _inputNode() {
        return /** @type {HTMLInputElement | HTMLTextAreaElement} */ (super._inputNode);
      }

      /** @type {number} */
      get selectionStart() {
        const native = this._inputNode;
        if (native && native.selectionStart) {
          return native.selectionStart;
        }
        return 0;
      }

      set selectionStart(value) {
        const native = this._inputNode;
        if (native && native.selectionStart) {
          native.selectionStart = value;
        }
      }

      /** @type {number} */
      get selectionEnd() {
        const native = this._inputNode;
        if (native && native.selectionEnd) {
          return native.selectionEnd;
        }
        return 0;
      }

      set selectionEnd(value) {
        const native = this._inputNode;
        if (native && native.selectionEnd) {
          native.selectionEnd = value;
        }
      }

      get value() {
        return (this._inputNode && this._inputNode.value) || this.__value || '';
      }

      // We don't delegate, because we want to preserve caret position via _setValueAndPreserveCaret
      /** @param {string} value */
      set value(value) {
        // if not yet connected to dom can't change the value
        if (this._inputNode) {
          this._setValueAndPreserveCaret(value);
          /** @type {string | undefined} */
          this.__value = undefined;
        } else {
          this.__value = value;
        }
      }

      /**
       * Restores the cursor to its original position after updating the value.
       * @param {string} newValue The value that should be saved.
       * @protected
       */
      _setValueAndPreserveCaret(newValue) {
        // Only preserve caret if focused (changing selectionStart will move focus in Safari)
        if (this.focused) {
          // Not all elements might have selection, and even if they have the
          // right properties, accessing them might throw an exception (like for
          // <input type=number>)
          try {
            // SelectElement doesn't have selectionStart/selectionEnd
            if (!(this._inputNode instanceof HTMLSelectElement)) {
              const start = this._inputNode.selectionStart;
              this._inputNode.value = newValue;
              // The cursor automatically jumps to the end after re-setting the value,
              // so restore it to its original position.
              this._inputNode.selectionStart = start;
              this._inputNode.selectionEnd = start;
            }
          } catch (error) {
            // Just set the value and give up on the caret.
            this._inputNode.value = newValue;
          }
        } else {
          this._inputNode.value = newValue;
        }
      }

      /**
       * @override FormatMixin
       */
      _reflectBackFormattedValueToUser() {
        super._reflectBackFormattedValueToUser();
        if (this._reflectBackOn() && this.focused) {
          try {
            // try/catch, because Safari is a bit sensitive here
            this._inputNode.selectionStart = this._inputNode.value.length;
            // eslint-disable-next-line no-empty
          } catch (_) {}
        }
      }
    };

  const NativeTextFieldMixin = dedupeMixin(NativeTextFieldMixinImplementation);

  /* eslint-disable max-classes-per-file */

  /**
   * @param {?} value
   */
  const isString = value => typeof value === 'string';

  class MaxLength extends Validator {
    static get validatorName() {
      return 'MaxLength';
    }

    /**
     * @param {?} value
     */
    execute(value, max = this.param) {
      let hasError = false;
      if (!isString(value) || value.length > max) {
        hasError = true;
      }
      return hasError;
    }
  }

  /* eslint-disable max-classes-per-file */

  /**
   * check for not being NaN (NaN is the only value in javascript which is not equal to itself)
   *
   * @param {number} value to check
   */
  const isNumber = value =>
    // eslint-disable-next-line no-self-compare
    value === value && typeof value === 'number';

  class IsNumber extends Validator {
    static get validatorName() {
      return 'IsNumber';
    }

    /**
     * @param {?} value
     */
    // eslint-disable-next-line class-methods-use-this
    execute(value) {
      let isEnabled = false;
      if (!isNumber(value)) {
        isEnabled = true;
      }
      return isEnabled;
    }
  }

  class MinNumber extends Validator {
    static get validatorName() {
      return 'MinNumber';
    }

    /**
     * @param {?} value
     */
    execute(value, min = this.param) {
      let isEnabled = false;
      if (!isNumber(value) || value < min) {
        isEnabled = true;
      }
      return isEnabled;
    }
  }

  class MaxNumber extends Validator {
    static get validatorName() {
      return 'MaxNumber';
    }

    /**
     * @param {?} value
     */
    execute(value, max = this.param) {
      let isEnabled = false;
      if (!isNumber(value) || value > max) {
        isEnabled = true;
      }
      return isEnabled;
    }
  }

  /**
   * LionInput: extension of lion-field with native input element in place and user friendly API.
   *
   * @customElement lion-input
   */
  class LionInput extends NativeTextFieldMixin(LionField) {
    /** @type {any} */
    static get properties() {
      return {
        /**
         * A Boolean attribute which, if present, indicates that the user should not be able to edit
         * the value of the input. The difference between disabled and readonly is that read-only
         * controls can still function, whereas disabled controls generally do not function as
         * controls until they are enabled.
         *
         * (From: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-readonly)
         */
        readOnly: {
          type: Boolean,
          attribute: 'readonly',
          reflect: true,
        },
        type: {
          type: String,
          reflect: true,
        },
        placeholder: {
          type: String,
          reflect: true,
        },
      };
    }

    get slots() {
      return {
        ...super.slots,
        input: () => {
          // TODO: Find a better way to do value delegation via attr
          const native = document.createElement('input');
          const value = this.getAttribute('value');
          if (value) {
            native.setAttribute('value', value);
          }
          return native;
        },
      };
    }

    /**
     * @type {HTMLInputElement}
     * @protected
     */
    get _inputNode() {
      return /** @type {HTMLInputElement} */ (super._inputNode); // casts type
    }

    constructor() {
      super();
      this.readOnly = false;
      this.type = 'text';
      this.placeholder = '';
    }

    /**
     * @param {PropertyKey} name
     * @param {?} oldValue
     */
    requestUpdateInternal(name, oldValue) {
      super.requestUpdateInternal(name, oldValue);
      if (name === 'readOnly') {
        this.__delegateReadOnly();
      }
    }

    /** @param {import('@lion/core').PropertyValues } changedProperties */
    firstUpdated(changedProperties) {
      super.firstUpdated(changedProperties);
      this.__delegateReadOnly();
    }

    /** @param {import('@lion/core').PropertyValues } changedProperties */
    updated(changedProperties) {
      super.updated(changedProperties);
      if (changedProperties.has('type')) {
        this._inputNode.type = this.type;
      }

      if (changedProperties.has('placeholder')) {
        this._inputNode.placeholder = this.placeholder;
      }

      if (changedProperties.has('disabled')) {
        this._inputNode.disabled = this.disabled;
        this.validate();
      }

      if (changedProperties.has('name')) {
        this._inputNode.name = this.name;
      }

      if (changedProperties.has('autocomplete')) {
        this._inputNode.autocomplete = /** @type {string} */ (this.autocomplete);
      }
    }

    /** @private */
    __delegateReadOnly() {
      if (this._inputNode) {
        this._inputNode.readOnly = this.readOnly;
      }
    }
  }

  /**
   * `LionInputStepper` is a class for custom input-stepper element (`<lion-input-stepper>` web component).
   *
   * @customElement lion-input-stepper
   */
  class LionInputStepper extends LionInput {
    static get styles() {
      return [
        ...super.styles,
        css`
        .input-group__container > .input-group__input ::slotted(.form-control) {
          text-align: center;
        }
      `,
      ];
    }

    /** @type {any} */
    static get properties() {
      return {
        min: {
          type: Number,
          reflect: true,
        },
        max: {
          type: Number,
          reflect: true,
        },
        step: {
          type: Number,
          reflect: true,
        },
      };
    }

    /**
     * @returns {number}
     */
    get currentValue() {
      return parseFloat(this.value) || 0;
    }

    get _inputNode() {
      return /** @type {HTMLInputElement} */ (super._inputNode);
    }

    constructor() {
      super();
      /** @param {string} modelValue */
      this.parser = modelValue => parseFloat(modelValue);
      this.min = Infinity;
      this.max = Infinity;
      this.step = 1;
      this.values = {
        max: this.max,
        min: this.min,
        step: this.step,
      };
    }

    connectedCallback() {
      super.connectedCallback();
      this.values = {
        max: this.max,
        min: this.min,
        step: this.step,
      };
      this.role = 'spinbutton';
      this.addEventListener('keydown', this.__keyDownHandler);
      this._inputNode.setAttribute('inputmode', 'decimal');
      this._inputNode.setAttribute('autocomplete', 'off');
      this.setAttribute('aria-label', this.label);
      this.step = this.hasAttribute('step') ? this.step : 1;
      this.__setAriaLabelsAndValidator();
      this.__toggleSpinnerButtonsState();
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.removeEventListener('keydown', this.__keyDownHandler);
    }

    /** @param {import('@lion/core').PropertyValues } changedProperties */
    updated(changedProperties) {
      super.updated(changedProperties);

      if (changedProperties.has('min')) {
        this._inputNode.min = `${this.min}`;
        this.values.min = this.min;
      }

      if (changedProperties.has('max')) {
        this._inputNode.max = `${this.max}`;
        this.values.max = this.max;
      }

      if (changedProperties.has('step')) {
        this._inputNode.step = `${this.step}`;
        this.values.step = this.step;
      }
    }

    get slots() {
      return {
        ...super.slots,
        prefix: () => this.__getDecrementButtonNode(),
        suffix: () => this.__getIncrementButtonNode(),
      };
    }

    /**
     * Set aria labels and apply validators
     * @private
     */
    __setAriaLabelsAndValidator() {
      const ariaAttributes = {
        'aria-valuemax': this.values.max,
        'aria-valuemin': this.values.min,
      };

      const minMaxValidators = /** @type {(MaxNumber | MinNumber)[]} */ (Object.entries(
        ariaAttributes,
      )
        .map(([key, val]) => {
          if (val !== Infinity) {
            this.setAttribute(key, `${val}`);
            return key === 'aria-valuemax' ? new MaxNumber(val) : new MinNumber(val);
          }
          return null;
        })
        .filter(validator => validator !== null));
      const validators = [new IsNumber(), ...minMaxValidators];
      this.defaultValidators.push(...validators);
    }

    /**
     * Update values on keyboard arrow up and down event
     * @param {KeyboardEvent} e - keyboard event
     * @private
     */
    __keyDownHandler(e) {
      if (e.key === 'ArrowUp') {
        this.__increment();
      }

      if (e.key === 'ArrowDown') {
        this.__decrement();
      }
    }

    /**
     * Toggle disabled state for the buttons
     * @private
     */
    __toggleSpinnerButtonsState() {
      const { min, max } = this.values;
      const decrementButton = this.__getSlot('prefix');
      const incrementButton = this.__getSlot('suffix');
      const disableIncrementor = this.currentValue >= max && max !== Infinity;
      const disableDecrementor = this.currentValue <= min && min !== Infinity;
      decrementButton[disableDecrementor ? 'setAttribute' : 'removeAttribute']('disabled', 'true');
      incrementButton[disableIncrementor ? 'setAttribute' : 'removeAttribute']('disabled', 'true');
      this.setAttribute('aria-valuenow', `${this.currentValue}`);
      this.dispatchEvent(
        new CustomEvent('user-input-changed', {
          bubbles: true,
        }),
      );
    }

    /**
     * Get slotted element
     * @param {String} slotName - slot name
     * @returns {HTMLButtonElement|Object}
     * @private
     */
    __getSlot(slotName) {
      return (
        /** @type {HTMLElement[]} */ (Array.from(this.children)).find(
          child => child.slot === slotName,
        ) || {}
      );
    }

    /**
     * Increment the value based on given step or default step value is 1
     * @private
     */
    __increment() {
      const { step, max } = this.values;
      const newValue = this.currentValue + step;
      if (newValue <= max || max === Infinity) {
        this.value = `${newValue}`;
        this.__toggleSpinnerButtonsState();
      }
    }

    /**
     * Decrement the value based on given step or default step value is 1
     * @private
     */
    __decrement() {
      const { step, min } = this.values;
      const newValue = this.currentValue - step;
      if (newValue >= min || min === Infinity) {
        this.value = `${newValue}`;
        this.__toggleSpinnerButtonsState();
      }
    }

    /**
     * Get the increment button node
     * @returns {Element|null}
     * @private
     */
    __getIncrementButtonNode() {
      const renderParent = document.createElement('div');
      /** @type {typeof LionInputStepper} */ (this.constructor).render(
        this._incrementorTemplate(),
        renderParent,
        {
          scopeName: this.localName,
          eventContext: this,
        },
      );
      return renderParent.firstElementChild;
    }

    /**
     * Get the decrement button node
     * @returns {Element|null}
     * @private
     */
    __getDecrementButtonNode() {
      const renderParent = document.createElement('div');
      /** @type {typeof LionInputStepper} */ (this.constructor).render(
        this._decrementorTemplate(),
        renderParent,
        {
          scopeName: this.localName,
          eventContext: this,
        },
      );
      return renderParent.firstElementChild;
    }

    /**
     * Toggle +/- buttons on change
     * @override
     * @protected
     */
    _onChange() {
      super._onChange();
      this.__toggleSpinnerButtonsState();
    }

    /**
     * Get the decrementor button sign template
     * @returns {String|import('@lion/core').TemplateResult}
     * @protected
     */
    // eslint-disable-next-line class-methods-use-this
    _decrementorSignTemplate() {
      return '－';
    }

    /**
     * Get the incrementor button sign template
     * @returns {String|import('@lion/core').TemplateResult}
     * @protected
     */
    // eslint-disable-next-line class-methods-use-this
    _incrementorSignTemplate() {
      return '＋';
    }

    /**
     * Get the increment button template
     * @returns {import('@lion/core').TemplateResult}
     * @protected
     */
    _decrementorTemplate() {
      return html`
      <button
        ?disabled=${this.disabled || this.readOnly}
        @click=${this.__decrement}
        tabindex="-1"
        type="button"
        aria-label="decrement"
      >
        ${this._decrementorSignTemplate()}
      </button>
    `;
    }

    /**
     * Get the decrement button template
     * @returns {import('@lion/core').TemplateResult}
     * @protected
     */
    _incrementorTemplate() {
      return html`
      <button
        ?disabled=${this.disabled || this.readOnly}
        @click=${this.__increment}
        tabindex="-1"
        type="button"
        aria-label="increment"
      >
        ${this._incrementorSignTemplate()}
      </button>
    `;
    }
  }

  customElements.define('lion-input-stepper', LionInputStepper);

  var _templateObject$7;

  class BasketItem extends HTMLElement {
    constructor() {
      super();
    }

    skuValidator(modelValue) {
      return modelValue > this.item.availableStock ? 'OUT OF STOCK' : '';
    }

    connectedCallback() {
      var updateQuantity = e => {
        this.item.quantity = e.currentTarget.value;
        this.updateItem(this.item);

        _render();
      };

      var _render = () => {
        console.log(this.item);
        var tmp = html(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral(["\n            <div class=\"basket-item\">\n                \n                <span>", "x</span>\n                <span>", "</span>\n                <small>", "</small>\n                \n                <button @click=", " class=\"btn-delete\">X Remove from basket</button>\n    \n                <lion-input-stepper \n                    class=\"input-stepper-wrapper\"\n                    .validators=\"", "\"\n                    value=", " \n                    max=", " \n                    @click=", "\n                    @keyup=", "\n                    step=\"1\" \n                    min=\"1\" \n                    name=\"quantity\">\n                </lion-input-stepper>\n                \n            </div>"])), this.item.quantity, this.item.title, this.item.deliveryTime, () => this.removeItem(this.item), [new MaxLength(1, {
          getMessage: _ref => {
            var {
              modelValue
            } = _ref;
            return this.skuValidator(modelValue);
          }
        })], this.item.quantity, this.item.availableStock, e => updateQuantity(e), e => updateQuantity(e));
        render$1(tmp, this);
      };

      _render();
    }

  }

  customElements.define('basket-item', BasketItem);

  var _templateObject$6, _templateObject2$4, _templateObject3$2, _templateObject4$1;

  class Basket extends HTMLElement {
    constructor() {
      super();
    }

    connectedCallback() {
      var confirmBasket = () => {
        this.handleStepChange(2);
      };

      var removeItem = item => {
        this.removeBasketItem(item);

        _render();
      };

      var updateItem = item => {
        this.updateBasketItem(item);

        _render();
      };

      var _render = () => {
        var tmp = html(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral(["\n            <div class=\"basket-wrapper\">\n                ", "\n                ", "\n            </div>"])), this.basketItems.map(item => html(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral(["\n                    <basket-item \n                        .updateItem=", " \n                        .removeItem=", " \n                        .item=", ">\n                    </basket-item>"])), updateItem, removeItem, item)), this.basketItems.filter(Boolean).length === 0 ? html(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["\n                    <h3>BASKET IS EMPTY!! GO SHOPPING :)</h3><button>Go to homepage</button>"]))) : html(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["<button @click=", ">Next step</button>"])), confirmBasket));
        render$1(tmp, this);
      };

      _render();
    }

  }

  customElements.define('basket-step', Basket);

  var _templateObject$5;

  class PaymentOption extends HTMLElement {
    constructor() {
      super();
    }

    connectedCallback() {
      var tmp = html(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n            <div @click=", " class=\"payment-option\">\n                <p>Pay with <b>", "</b> bank</p>\n            </div>"])), e => this.onSelect(e, this.option), this.option.bank);
      render$1(tmp, this);
    }

  }

  customElements.define('payment-option', PaymentOption);

  var _templateObject$4, _templateObject2$3;

  class Payment extends HTMLElement {
    constructor() {
      super();
      this.orderId = null;
      this.paymentId = null;
      this.totalAmount = null;
      this.paymentOptions = [];
    }

    validatePayment(orderId, paymentId) {
      return fetch("/assets/mocks/payment_validate_".concat(paymentId, ".json"), {
        method: "POST",
        body: JSON.stringify({
          orderId
        })
      }).then(res => res.json()).then(res => {
        // verify when the status of validation is healthy!!!
        if (res.status === 'PAYMENT_CONFIRMED') {
          this.handleStepChange(4);
        } else {
          alert('BAMMM!!! Your balance is not enough to proceed the payment!!!');
        }
      }).catch(err => {
        alert('Something is wrong with the services! Please try again...');
      });
    }

    fetchPaymentOptions() {
      return fetch("/assets/mocks/payment_options.json").then(res => res.json());
    }

    connectedCallback() {
      //1. reserve the basket first and get the order id
      //2. fetch payment options and render
      //3. send payment information to server to validate
      //4. If it was valid go to confirmation step otherwise show error
      fetch("/assets/mocks/reserve_basket.json", {
        method: 'POST',
        body: JSON.stringify(this.basketItems)
      }).then(res => res.json()).then(res => {
        this.orderId = res === null || res === void 0 ? void 0 : res.orderId;
        this.totalAmount = res === null || res === void 0 ? void 0 : res.total_amount;
        this.fetchPaymentOptions().then(res => {
          this.paymentOptions = res === null || res === void 0 ? void 0 : res.options;

          _render();
        }).catch(err => {
          //TODO: popup error notification message
          _render();
        });
      });

      var selectPaymentOption = (e, payment) => {
        // deselect the other payment options
        document.querySelectorAll('.payment-option').forEach(el => el.classList.remove('payment-active'));
        e.currentTarget.classList.add('payment-active');
        this.paymentId = payment.id;

        _render();
      };

      var _render = () => {
        var tmp = html(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n            <div class=\"payment-wrapper\">\n                <h2>Payment</h2>\n                <h3>Total amount to pay: ", "</h3>\n                <p>Select one of the payment options before proceed your order:</p>\n                \n                ", "\n                \n                <footer>\n                    <button class=", " @click=", ">Confirm Payment</button>\n                </footer>\n            </div>"])), this.totalAmount, this.paymentOptions.map(paymentOption => html(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral(["<payment-option \n                            .onSelect=", " \n                            .option=", ">\n                            .selected=", "\n                        </payment-option>"])), selectPaymentOption, paymentOption, this.paymentId === paymentOption.id)), this.paymentId ? "btn-primary" : "btn-disabled", () => this.validatePayment(this.orderId, this.paymentId));
        render$1(tmp, this);
      };
    }

  }

  customElements.define('payment-step', Payment);

  customElements.define('lion-input', LionInput);

  var _templateObject$3, _templateObject2$2;

  class Delivery extends HTMLElement {
    constructor() {
      super(); // default values

      this.customer = {
        fullname: '',
        email: '',
        phone: '',
        address: {
          street: '',
          houseNumber: '',
          houseNumberAddition: '',
          postalCode: '',
          city: ''
        }
      };
      this.hasVoucher = false;
      this.addressFields = Object.keys(this.customer.address);
    }

    connectedCallback() {
      // check if all the items in the basket are voucher
      this.hasVoucher = this.basketItems.every(item => item.fulfillmentType === 'VOUCHER'); // prefill customer address only when it's available

      fetch("/assets/mocks/customer.json").then(res => res.json()).then(res => {
        this.customer.address = res === null || res === void 0 ? void 0 : res.addresses[0];
        this.customer.fullname = res === null || res === void 0 ? void 0 : res.correspondenceName;
        this.customer.email = res === null || res === void 0 ? void 0 : res.personalEmailAddress;
        this.customer.phone = res === null || res === void 0 ? void 0 : res.phoneNumber;

        _render();
      }).catch(() => {
        _render();
      });

      var confirmDeliveryAddress = () => {
        var deliveryAddress = [];

        if (!this.hasVoucher) {
          this.addressFields.map(field => deliveryAddress[field] = document.getElementById(field).value);
        }

        this.handleDeliveryAddress(deliveryAddress);
      };

      var _render = () => {
        var tmp = html(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n            <div class=\"delivery-wrapper\">\n           \n                <h2>Delivery information</h2>\n                \n                <form name=\"addressFields\">\n                    <lion-input type=\"text\" .value=", " name=\"fullname\" placeholder=\"Full name\"></lion-input>\n                    <lion-input type=\"email\" .value=", " name=\"email\" placeholder=\"Email\" ></lion-input>\n                    ", "\n                    <lion-input type=\"text\" .value=", " name=\"phone\" placeholder=\"Phone\" ></lion-input>\n                </form>\n\n                <footer>\n                    <button @click=", ">previous step</button>\n                    <button class=\"btn-primary\" @click=", ">Next step</button>\n                </footer>\n\n            </div>"])), this.customer.fullname, this.customer.email, !this.hasVoucher ? html(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["\n                    <lion-input type=\"text\" .value=", " id=\"street\" name=\"street\" placeholder=\"Street\" ></lion-input>\n                    <lion-input type=\"text\" .value=", " id=\"houseNumber\" name=\"houseNumber\" placeholder=\"House number\" ></lion-input>\n                    <lion-input type=\"text\" .value=", " id=\"houseNumberAddition\" name=\"houseNumberAddition\" placeholder=\"Additional House Number\" ></lion-input>\n                    <lion-input type=\"text\" .value=", " id=\"postalCode\" name=\"postalCode\" placeholder=\"Postal Code\" ></lion-input>\n                    <lion-input type=\"text\" .value=", " id=\"city\" name=\"city\" placeholder=\"City\" ></lion-input>"])), this.customer.address.street, this.customer.address.houseNumber, this.customer.address.houseNumberAddition, this.customer.address.postalCode, this.customer.address.city) : "", this.customer.phone, () => this.handleStepChange(1), () => confirmDeliveryAddress());
        render$1(tmp, this);
      };
    }

  }

  customElements.define('delivery-step', Delivery);

  var isAddressValid = address => {
    return (address === null || address === void 0 ? void 0 : address.street) && (address === null || address === void 0 ? void 0 : address.city) && (address === null || address === void 0 ? void 0 : address.postalCode);
  };

  var _templateObject$2, _templateObject2$1, _templateObject3$1;

  class Confirmation extends HTMLElement {
    constructor() {
      super();
    }

    connectedCallback() {
      var tmp = html(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["<div class=\"confirmation-wrapper\">\n            <h2>Thank you for placing your order!</h2>\n\n            ", "\n\n            ", "\n\n            <footer>\n                <button>Go To Homepage</button>\n            </footer>\n        </div>"])), this.basketItems.map(item => html(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["\n            <div class=\"basket-item\">\n                <span>", "X</span>\n                <span>", "</span>\n                <small>", "</small>\n            </div>"])), item.quantity, item.title, item.deliveryTime)), isAddressValid(this.deliveryAddress) ? html(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["\n                <h3>Delivery Address: </h3> \n                <h4>\n                    ", ", \n                    ", " ", "\n                    ", ", \n                    ", "\n                </h4>\n            "])), this.deliveryAddress.street, this.deliveryAddress.houseNumber, this.deliveryAddress.houseNumberAdditional, this.deliveryAddress.postalCode, this.deliveryAddress.city) : "");
      render$1(tmp, this);
    }

  }

  customElements.define('confirmation-step', Confirmation);

  var _templateObject$1, _templateObject2, _templateObject3, _templateObject4, _templateObject5;

  class Steps extends HTMLElement {
    constructor() {
      super();
      this.basketItems = [];
      this.deliveryAddress = [];
    }

    connectedCallback() {
      // fetch the basket items before rendering the steps
      fetch("/assets/mocks/basket.json").then(res => res.json()).then(res => {
        this.basketItems = res === null || res === void 0 ? void 0 : res.basket;

        _render();
      }).catch(() => {
        _render();
      });

      var findIndexBasketItem = item => {
        return this.basketItems.findIndex(_item => _item ? _item.productId === item.productId : false);
      }; // remove the item from basket


      var removeBasketItem = item => {
        var idx = findIndexBasketItem(item);
        delete this.basketItems[idx];
      }; // update the item details in basket


      var updateBasketItem = item => {
        var idx = findIndexBasketItem(item);
        this.basketItems[idx] = item;
      }; // re-render the steps status after navigation between steps


      var handleStepChange = step => {
        this.step = step;

        _render();
      }; // save the delivery address before proceed to payment


      var handleDeliveryAddress = address => {
        this.deliveryAddress = address;
        console.log(address);
        handleStepChange(3);
      };

      var _render = () => {
        var tmp = html(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n            <lion-steps class=\"steps-wrapper\">\n                <lion-step class=\"step-item\" initial-step>\n                    <label class=", ">1 Basket</label>\n                </lion-step>\n                <lion-step class=\"step-item\">\n                    <label class=", ">2 Delivery</label>\n                </lion-step>\n                <lion-step class=\"step-item\">\n                    <label class=", ">3 Payment</label>\n                </lion-step>\n                <lion-step class=\"step-item\">\n                    <label class=", ">4 Confirmation</label>\n                </lion-step>\n        \n                <div class=\"step-container\">\n                    ", "\n                    ", "\n                    ", "\n                    ", "\n                </div>\n            </lion-steps>"])), this.step === 1 ? 'step-active' : '', this.step === 2 ? 'step-active' : '', this.step === 3 ? 'step-active' : '', this.step === 4 ? 'step-active' : '', this.step === 1 ? html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n                        <basket-step \n                            .updateBasketItem=", " \n                            .removeBasketItem=", " \n                            .basketItems=", " \n                            .handleStepChange=", ">\n                        </basket-step>"])), updateBasketItem, removeBasketItem, this.basketItems, handleStepChange.bind(this)) : "", this.step === 2 ? html(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n                        <delivery-step \n                            .basketItems=", " \n                            .handleDeliveryAddress=", " \n                            .handleStepChange=", ">\n                        </delivery-step>"])), this.basketItems, handleDeliveryAddress.bind(this), handleStepChange.bind(this)) : "", this.step === 3 ? html(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n                        <payment-step \n                            .basketItems=", " \n                            .handleStepChange=", ">\n                        </payment-step>"])), this.basketItems, handleStepChange.bind(this)) : "", this.step === 4 ? html(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n                        <confirmation-step \n                            .deliveryAddress=", " \n                            .basketItems=", ">\n                        </confirmation-step>"])), this.deliveryAddress, this.basketItems) : "");
        render$1(tmp, this);
      };
    }

  }

  customElements.define('steps-bar', Steps);

  var _templateObject;

  class App extends HTMLElement {
    constructor() {
      super();
      this.step = 1;
    }

    connectedCallback() {
      var tmp = html(_templateObject || (_templateObject = _taggedTemplateLiteral(["<steps-bar .step=", "></steps-bar>"])), this.step);
      render$1(tmp, this);
    }

  }

  customElements.define('ing-app', App);

}());
